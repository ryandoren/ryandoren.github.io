[{"categories":null,"content":"前言 人们或许听说过 《马太福音》📕，也听说过 “马太效应”。但是，关于【马太】这个人，却知之寥寥。【圣马太】(Saint Matthew) 是基督耶稣的十二使徒之一，也是第一卷福音书的作者。在成为耶稣的门徒之前，犹太人马太是迦百农的一名税吏💰，他终日坐在罗马税关之上，招呼着过往的人们缴税。而 “马太效应” 则出自 《新约·马太福音》 中的一句话： 凡有的，还要加倍给他叫他多余；没有的，连他所有的也要夺过来。 马太受耶稣感召的场景成为后世艺术家们津津乐道的题材。在 《马太福音》 中，对这个命运转变时刻的记录十分简略： 耶稣从那里往前走，看见一个人税吏，名叫利未，坐在税关上，就对他说，你跟从我来。他就起身跟从了耶稣。 【卡拉瓦乔】非常认同其中的思想，因为自身性格和相关经历，他很擅长刻画某种可能的==救赎==，这种救赎落在最不可能、最顽固的==罪人==身上。这幅画中，他描绘的是自己的本性，是自己熟悉的人物，是罗马现实生活中的场景，因而当时的看画人也会觉得，卡拉瓦乔的这幅画连接了历史与当下，也连接了平凡与神圣。 画面整体 卡拉瓦乔并没有沿用圣经中所描述的地点，而是创造性地把场景设置在一个阴暗的角落里，我们很难分辨这是室内还是室外，或许是破旧的酒馆，甚至可能是赌场的一隅。他将圣马太蒙召这一瞬间表现为一种==近乎无声的、戏剧性的叙述==，仿佛一切动态都在一瞬间被定格。收税人【利未】（Levi，圣马太成为使徒之前的名字）和他的四个随从围坐在一张桌子旁，桌上随意散落着金币，他们似乎正在专心致志地数着当天的收入。 突然，一束光自右上角射入，照亮了这群人；顺着光源的方向，我们就能看见耶稣——他与【圣彼得】一同进入，身着古旧的袍子，赤裸双脚，看上去与凡人别无二样，唯有 ==头顶的光环==暗示着他的神性😇。他 ==右手==召唤马太的手势，仿佛由于无力和疲倦而显得更加具有神的力量，引人注目。马太对这两位陌生人的闯入感到惊讶Σ(っ °Д °;)っ，也可能是被突然射入的强光炫得眼花缭乱。他身体后倾，用 ==左手==指了指自己👈，好像在说，“谁？我？”，而他的 ==右手==仍停留在正在数着的金币上，还没来得及反应。圣彼得也指向马太，同时转身对着耶稣，似乎在问：“是他吗？”🤔“对，就是你，马太！”这三个人的手势让画面上的故事顿时生动起来，也将马太从世俗生活中剥离出来，从此税吏利未成为圣徒马太。 这样的场景好似现代电影中的一个镜头📽️，充满了戏剧性和紧迫感，它也是卡拉瓦乔作品最具代表性的风格，让观众仿佛置身画中，切身感受到当时的气氛。 细节解读 ","date":"2021-10-18","objectID":"/the-calling-of-saint-mathew/:0:0","tags":null,"title":"卡拉瓦乔《圣马太蒙召》","uri":"/the-calling-of-saint-mathew/"},{"categories":null,"content":"桌子左边的数金币者 首先，我们来打量一下左边这两个头也不抬，一心数着金币的人。其中一个年长一些的，半弓着腰，眉头紧锁，严肃地抿着嘴。耶稣的圣光照得他那顶着稀稀疏疏银发的脑门子闪闪发光。他用手扶了扶眼镜，极力想数清桌上金币的数目，仿佛心里面在盘算着自己能分到多少银两。他在视力和道德上都是极其短视的。 另一位坐在桌子最左侧、低着头的小伙，眼睛死死地盯着桌上的金币，双肘将身体撑在桌子边缘，左手支在右臂后方，右手轻轻搭在桌上，整体呈现出蠢蠢欲动的状态，好像下一秒就要伸手去拿金币。这两个人如此关心数钱，以至于他们甚至没有注意到耶稣的到来，他们对基督的漠视剥夺了他们获得永生的机会。 某些艺术史学家认为，这两个人物可能在某种程度上受到了【小汉斯·霍尔拜因】 (Hans Holbein the Younger) 的启发✨。在荷尔拜因的 ==木版画《死亡之舞》之十一《赌徒》== 中，三名赌徒坐在桌子旁边，死神和魔鬼为了抢夺中间这名赌徒而产生了争执，左边的这一位似乎在替他的同伴向死神说情，而右边的这一位则闷着头计算着账目，丝毫未注意到死神和魔鬼正在夺取他的朋友。这幅画以一种类似黑色幽默的手法，生动地讽刺了右边这位赌徒对金钱的痴迷，以致于完全忽视了死神和魔鬼的降临。 ","date":"2021-10-18","objectID":"/the-calling-of-saint-mathew/:1:0","tags":null,"title":"卡拉瓦乔《圣马太蒙召》","uri":"/the-calling-of-saint-mathew/"},{"categories":null,"content":"桌子右边的年轻男孩 桌子右边的两个男孩确实对耶稣的到来做出了回应。面向我们的、稍显年轻的这一个，粉嫩的小脸蛋被圣光照得通亮，他目不转睛地看着两位“不速之客”，下意识地靠向了马太，以寻得一丝安全感。他的手臂搭在马太的肩膀上，好像在说：“大哥，这两个人是不是来找你的啊？” 实际上，正脸面向我们的男孩，是卡拉瓦乔非常喜爱的一名男模特， ==【马里奥·明尼蒂 】(Mario Minniti)==，他曾在卡拉瓦乔的多幅作品中出现过，包括： 《捧着水果篮的男孩》，1593， Boy with a Basket of Fruit 1593 《算命者》，1594 \u0026 1599，The Fortune Teller 1599 《老千》，1594, 两个人物同一个模特，Cardsharps 1594 《音乐家》，1595，两个人物同一个模特Musicians 1595 《酒神巴库斯》，1596，Bacchus 1596 《被蜥蜴咬伤的男孩》，1596，Boy Bitten by a Lizard 1596 《鲁特琴演奏者》，1596，柏明顿庄园版，The Lute Player 1596, Ex-Badminton House, Gloucestershire 《鲁特琴演奏者》，1596，Wildenstein版，The Lute Player 1596, Private Collection. Wildenstein Collection 《圣马太蒙召》，1599，Calling of Saint Matthew 1599 《圣马太殉难》，1599，Martyrdom of Saint Matthew 1599 这里放上关于明尼蒂的一些补充介绍，主要聊了明尼蒂作为卡拉瓦乔的“御用”模特，都“参演过”哪些画作，感兴趣的朋友可以移步这篇文章。 Mario Minniti as a model in Caravaggio’s works 而背对我们的、稍显年长的那一个男孩，则多了几分痞气。他上半身略带威胁地向着两位陌生人转去，左手下意识地摸向腰间的佩剑🗡，右手撑着凳子的一角，腿部肌肉和跟腱绷紧，左脚点地，仿佛就要起身。作为全场唯一一个佩戴了武器的人，他仿佛是专门坐在门口以防“分赃”过程被打断的“保安”🛡️，这样看来，他的警觉和敌意就显得十分自然了。 ","date":"2021-10-18","objectID":"/the-calling-of-saint-mathew/:2:0","tags":null,"title":"卡拉瓦乔《圣马太蒙召》","uri":"/the-calling-of-saint-mathew/"},{"categories":null,"content":"从利未到圣马太 我们可能会感到疑惑🤔：为什么画面中的马太一脸讶异，为什么圣彼得要反复追问？ 原来，税吏这一职业在当时人们心目中是十分罪恶的，税吏马太无疑会被人当作罪人。而圣人耶稣竟然愿意感召一名罪人，就连马太自己也感到诚惶诚恐。😱 罗马共和国时期，一方面，国土不断扩张，大量的财富与人口涌入罗马，财政事务复杂；另一方面，系统完备的财政管理机构和制度始终没有形成，管理水平低下。大量的财富资源得不到有效合理的安排与利用，严重阻碍了罗马经济的健康发展。税负加重，人民生活日益贫困，消费市场日渐萎缩，农业衰落又使工商业生产原料减少，而手工业和商业的衰落进一步影响到帝国的税收收入，最终帝国的税收与财政到了崩盘的边缘。因此，这个时代的税吏实属罪大恶极的职业。😈 另一方面，这也体现了耶稣的怜悯。马太福音中记载了圣马太蒙召之后的一段故事： 为了感谢他（耶稣），马太在他家里举行了盛大的宴会。有好几个税吏和罪人和耶稣与他的门徒坐在一起。法利赛人和他们的文士看见了，就问耶稣的门徒：“你们的主人为什么与税吏和罪人一起吃饭呢？”当他听到这句话时，他回答说：“需要医生的不是健康的人，而是病人。去学习这句话的意思：怜悯是我所喜悦的，而不是牺牲。的确，我不是来召叫正直人，而是召叫罪人。” 我们再回到画面，当“信仰之光”✨打在马太困惑的脸上，他的两颊由于忽被“点名”而变得通红。对于神圣的召唤，他做出了每个罗马人、每个朝圣者都会认出的反应：“什么？我？”有些学者说，此处的圣马太是谁其实难以确定。也许这位大胡子男🧔🏼指向的是另一个人——桌子尽头弓着背的年轻人，嘴里说的是：“你是指他吗？”（暗示这位年轻人是马太）；还有一些人认为卡拉瓦乔的画是故意模棱两可的。但在我而言，毫无疑问，即将成为门徒马太的就是这个满脸胡须的人。因为他衣着华丽，也是卡拉瓦乔自己最喜欢的黑天鹅绒，这就使得税吏向谦卑的皈依更加生动。 ","date":"2021-10-18","objectID":"/the-calling-of-saint-mathew/:3:0","tags":null,"title":"卡拉瓦乔《圣马太蒙召》","uri":"/the-calling-of-saint-mathew/"},{"categories":null,"content":"耶稣右手与头顶的圣光 基督没有在画面正中，而是身处黑暗，这引得观者去寻找他的存在。而那束光给了我们绝妙的提示。从神学角度说，这是完美的处理，因为圣彼得介于众人和基督之间，就像他在教会制度中的作用一样。这种处理在心理层面也很出色，因为基督仅仅展现出部分身体，这就将大家的注意力都放在一个无法忽视的部位：他伸出的胳膊和有指向的手指。这是神圣与世俗的完美结合，而且也正是整个故事的核心。 ==耶稣的这个手势源于米开朗基罗的西斯廷天顶画《创造亚当》==，他伸出的右手，几乎是亚当左手的镜像。==上帝的手指与亚当的手指即将触碰，象征着神的智慧和灵性即将随着灵魂一起注入人体；同样地，耶稣将这一手势传递下去，将神的宽恕给予他的使徒。== 卡拉瓦乔之所以在描摹耶稣时借用《创造亚当》中亚当的手势，是因为耶稣在新约中被描绘为==最后的亚当==或==第二个亚当==(the Last Adam/the Second adam)。在圣经新约中，保罗将耶稣和亚当进行了两次明确的比较： 因一人的悖逆，众人成为罪人；照样，因一人的顺从，众人也成为义了。 ——罗马书 5:19 在亚当里众人都死了。照样，在基督里众人也都要复活。 ——哥林多前书 15:22 而在 45 节中，他称耶稣为 ==“最后的/终极的/最终的亚当” (the last/ultimate/final Adam)==。 我们再来看看卡拉瓦乔的酒窖式光线。在《圣马太蒙召》中，一束光线似乎自耶稣头顶（而不是来自肮脏的窗户），顺着他的手，射向了画面的左侧。这里很多学者曾对窗户的作用提出了疑问。有的人认为窗户是为了光线的漫反射而存在。但我觉得，比较令人信服的说法是，这里暗淡的窗户象征着教会：它只是一种形式，并不能带来真正的光芒；真正的福音之光源自于基督，源自于对耶稣的信仰。 特点总结 ","date":"2021-10-18","objectID":"/the-calling-of-saint-mathew/:4:0","tags":null,"title":"卡拉瓦乔《圣马太蒙召》","uri":"/the-calling-of-saint-mathew/"},{"categories":null,"content":"戏剧性和张力 这幅画的戏剧性在于，这一刻，没有人做任何事情，但我们都能预见下一秒将发生什么。 基督这一瞬时的出现是如此出人意料；他的姿态如此威严，以至于在场的每一个人在发生反应之前都暂停了行动。再过一秒，马太就会站起来跟随基督而去——他腿部动势和肌肉的曲张已经暴露了这一点。另外，仔细观察画面右下角也能发现，基督的脚事实上已经调转了方向，仿佛就要离开这个房间。他来此只是为了告知使徒他已被选中，不做任何停留，并且心里仿佛早就知道马太会毫不犹豫地跟随自己。这幅画的特殊力量就在于这种动作的停止。有如牵丝木偶忽被拉紧了线，让人心头也倏地一震。 之后的动作虽“呼之欲出”且“显而易见”，却也留足了悬念，给了观者思考与想象的空间。==它利用了绘画最基本的静态感传达出了人类动态的情感——在面临挑战或命令，并且尚未来得及反应之时的，那种典型的内心矛盾与犹豫不决。== ","date":"2021-10-18","objectID":"/the-calling-of-saint-mathew/:5:0","tags":null,"title":"卡拉瓦乔《圣马太蒙召》","uri":"/the-calling-of-saint-mathew/"},{"categories":null,"content":"构图与对比 画面分为两部分。基督和圣彼得矗立在右侧，形成了一个竖直的矩形；画面左侧围坐在桌子旁的人们形成了一个水平的模块。卡拉瓦乔以鲜艳的色彩使这幅画栩栩如生：红色、金色和绿色的大胆对比。此外，天鹅绒和软毛皮等各种质地的服装也加强了人物的对比：仍在世俗纷争中苦苦挣扎的利未和他的部下们，穿着具有当代风格的衣服；而基督和圣彼得，赤着双脚，身着具有象征意义和永恒性的斗篷，将利未召唤到另一个了无俗尘的世界。==这两个群体被一个虚空隔开，由基督的手从画面上并且从象征意义上连接了起来==。 这只手，就像米开朗基罗《创造亚当》中，亚当的手一样，在形式上和心理上统一了两部分。在画面舞台式的空间之下，是纵横交错的网格布局，将整体在结构上编织在一起。 ","date":"2021-10-18","objectID":"/the-calling-of-saint-mathew/:6:0","tags":null,"title":"卡拉瓦乔《圣马太蒙召》","uri":"/the-calling-of-saint-mathew/"},{"categories":null,"content":"卡拉瓦乔的酒窖光线 画面的光线也同样经过精心处理：画面右上角的光源，犹如酒窖掀开时，钻缝而入的光线一般，投射在画面左侧人群的脸上，从而将圣马太和随从们脸部的神情展现地淋漓尽致。而这与基督一同进入了这间屋子的光，不是自然光也不是灯光，而是象征着上帝的、神圣的、奇迹般的光芒✨。否则，为什么圣彼得没有在佩剑男孩身上投下影子呢？ ","date":"2021-10-18","objectID":"/the-calling-of-saint-mathew/:7:0","tags":null,"title":"卡拉瓦乔《圣马太蒙召》","uri":"/the-calling-of-saint-mathew/"},{"categories":null,"content":"Intro to Computing in Python by David Joyner","date":"2021-10-17","objectID":"/gatech-cs1301xi/","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":" Extra materials How to Think Like a Computer Scientist: Interactive Edition How to Think Like a Computer Scientist: Learning with Python 3 Python for Everybody (PY4E) Course Outline ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:0:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Unit 1 Computing: the basic principles of working with computers. Programming: the general workflow of writing and running programs. Writing code, compiling it, executing it, and evaluating the results. Debugging: the process of finding and fixing errors in your programs. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:1:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Unit 2 Procedural Programming: The general idea of writing sequences of instructions for the computer to perform. Variables: Creating and modifying data in our programs. Logical Operators: Establishing the truth or falsehood of relationships among variables in our programs. Mathematical Operators: Using arithmetic operators (addition, multiplication, etc.) to modify the values of variables in our programs. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:2:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Unit 3 Control Structures: The general idea of lines of code that can control other lines of code. Conditionals: Lines of code (called if statements) that check logical expressions to see if certain code blocks should run. Loops: Lines of code that instruct the computer to repeat a block of code until some condition is met. Functions: Miniature programs within a larger program, each with their own input, code, and output. Exception Handling: Lines of code that instruct the computer how to fail gracefully when errors are encountered. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:3:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Unit 4 Data Structures: The general idea of data types more complex than individual letters and numbers. Strings: Ordered series of characters that often represent natural human language. Lists: Ordered series of other kinds of data, collected under one variable name and accessed via numeric indices. File Input/Output: Writing a program’s data to a file so it can later be re-loaded after the program is closed and reopened. Dictionaries: Pairs of keys and values collected under one variable name, like lists with non-numeric indices. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:4:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Unit 5 Objects: Creating and using custom data types so our programs can reason about the world the way we do. Algorithms: Complex sequences of instructions that transform data or generate useful conclusions. Unit 1 ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:5:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Chapter 1.1: Computing ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:6:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Programming Vocabulary Code: Commands given to a computer in order to perform a task. Line of code: A single command. Program: A collection of lines of code that serve one or more overall functions. Input (files, user input, websites) 👉 code 👉 output (files, screen, sound) Compile: To translate human-readable computer code into low-level commands the computer can execute. In the programming flow, this functions as reading over code and looking for errors. (proofreading by compilers) Run/Excution: Running some code and having it actually perform its operations. Compiling just makes sure what we told the program to do makes sense; running checks whether the program actually do what we want it to do. Compilation could potentially be skipped. Languages that require compilation are called static/compiled languages. Languages that do not require compilation are called dynamic/interpreted languages. Two kinds of programs process high-level languages into low-level languages: interpreters and compilers. An interpreter reads a high-level program and executes it. It processes the program a little at a time, alternately reading lines and performing computations. A compiler reads the program and translates it completely before the program starts running. In this case, the high-level program is called the source code, and the translated program is called the object code or the executable. Once a program is compiled, you can execute it repeatedly without further translation. Many modern languages use both processes. They are first compiled into a lower level language, called byte code, and then interpreted by a program called a virtual machine. Python uses both processes, but because of the way programmers interact with it, it is usually considered an interpreted language. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:6:1","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Programming Language Categorization of languages: Static \u0026 Dynamic: whether compilation is required Hight-level languages involve a great deal of abstraction from the low-level details of the computer like memory, whereas low-level languages such as machine languages or assembly languages require these details to be addressed manually. Popularity of different languages C++ and C# are two successors to the programming language C, which is a low-level language used a lot in developing operating systems, video games, and other highly complex programs. C++ adds a few more features to C, while C# is more of a high-level version. Java, C, C++, and C# are static, compiled languages; Python is the top dynamic, scripting language on this list. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:6:2","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Console vs. GUI Graphical user interfaces (GUIs): An output medium that uses more than just text, like forms, buttons, tabs, and more. Eg. a web brower, a word processor like Microsoft Word, a smartphone app, a modern operating system like Windows or Mac OS. Console: An output medium for a program to show exclusively text-based output. Eg. command line interfaces like the terminal on a Mac or the command window on a PC. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:6:3","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Fundations, language, and domain Foundations are the core principles of computing that transcend specific programming languages. These foundational principles are then implemented in specific programming languages. You then apply them to a particular domain. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:6:4","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Python Python is a high-level, platform independent programming language. Python abstracts further away from the inner workings of the computer than lower-level languages (like memory management), thus is easier to use. Python is dynamic \u0026 interpreted, which means that Python will run our code line by line when we ask it to without trying to compile it first. That opens up the possibility of using Python in a command line interface where we write and run lines of code one at a time. Whereas in the scripting mode, we write a bunch of code, then run it all at once. The main takeaway of Python being an interpreted language is that we might not be aware of errors until we actually try to run those lines. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:6:5","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Extra materials How to Think Like a Computer Scientist: Interactive Edition How to Think Like a Computer Scientist: Learning with Python 3 ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:6:6","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Chapter 1.2: Programing Programming is an iterative process of writing code, attempting to run it, and evaluating the results (write⇨run⇨evaluate cycle). Interchangeable with coding. Work in Small Chunks Chaining Together Instructions Debugging to address errors, incorrect results ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:7:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Chapter 1.3: Debugging Debugging: Resolving problems in code, whether it be errors thrown in compilation or running or mismatches between the desired and observed output. The terms “bug” and “debugging” are popularly attributed to Admiral Grace Hopper in the 1940s. While she was working on a Mark II Computer at Harvard University, her associates discovered a moth stuck in a relay and thereby impeding operation, whereupon she remarked that they were “debugging” the system. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:8:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Types of errors Compilation Errors: Errors that occur during the computer’s read through of the code. Compilation errors in writing programs are often similar to grammatical errors in writing essays. sytax errors: code that doesn’t work with the current programming language. name errors: code that tries to use something that doesn’t exist. type errors: code that matches different types together, which doesn’t make sense. Depending on the language, some of these might turn up as runtime errors instead. Runtime errors: Errors that arise when trying to actually execute the code. Languages that don’t have compilation will only have runtime errors. Even languages that do require compilation can have runtime errors because we can’t anticipate every error just by looking at the code. Divide by zero errors: code that divides a value by zero. Null errors: code that refers to some variable that has no value. Memory errors: code that surpasses your computer’s memory. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:8:1","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Types of errors in Python NameError An error that usually occurs when you use a variable name that doesn’t yet exist. When you encounter these, check first for misspellings; you very likely might have misspelled a variable name, causing the computer to see it as a completely different variable! If that doesn’t work, try to find where you first defined the variable. TypeError An error that occurs when we try to perform an operation on an object that doesn’t make sense with the operation, like calculating the length of a number or to print an omelette. The function cannot deal with the object. AttributeError An error occurs when we ask for information about a variable that doesn’t make sense, like the happiness of a potato or the GPA of a turnip. The object does not have the attribute. SyntaxError An error that occurs when the line of code we’ve written can’t be read by the computer because it doesn’t match the computer’s expectation for the programming language’s grammar. Others Check the debugging guide. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:8:2","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Basic debugging Print Debugging: A form of debugging where print statements are added throughout the code to check how the program is flowing. Scope Debugging: A form of debugging where print statements are added to check the status of the variables in the program at different stages to see how they are changing. (Debugging small sections/scopes of a program to make sure things have run correctly so far.) Rubber Duck Debugging: A form of debugging where the programmer explains the logic, goals, and operations to an inanimate listener to methodically step through the code. The point is when faced with a hard to solve problem, try explaining it from scratch. Oftentimes, you’ll find the solution. Rubber duck debugging was introduced by the 1999 book The Pragmatic Programmer, and it refers to a programmer who carried around a rubber duck to which to explain problems. By explaining things to the duck, the programmer often found the solution. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:8:3","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Advanced debugging Step by step execution: run your code one line at a time. Variable visualization: you can view the status of every variable at any time. In-line debugging: while you’re writing code, it’ll show you right there if you’ve done something wrong; visualized very similarly to spell check. It’s almost as if the computer is constantly compiling your code, just to make sure it works, while you’re writing it. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:8:4","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Chapter 2.1: Procedural Programming ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:9:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Function and Method Function: A segment of code that performs a specific task, sometimes taking some input and sometimes returning some output. Method: A function that is part of a class in object-oriented programming (but colloquially, often used interchangeably with function). ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:9:1","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Programming paradigms Procedural Programming: where procedural code is the one that directly instructs a device on how to finish a task in logical steps. Object-Oriented Programming: A programming paradigm where programmers define custom data types that have custom methods embedded within them. A concept or an abstraction is created before excuting some other commands. Event-Driven Programming: A type of programming where the program generally awaits and reacts to events rather than running code linearly. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:9:2","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Operators Operators: Specific, simple functions that act on primitive data types, like integers and strings. Mathematical Operators: Operators that perform mathematical functions, like adding numbers together or assigning values to variables. (+ - * / % **) Logical Operators: Operators that perform logical operations, such as comparing relative values, checking equality, checking set membership, or evaluating combinations of other logical operators. Typically, operators work on the most primitive types in programming languages: mathematical operators work on integers and floats, while logical operators work on booleans. Some languages, though, allow us to use operators in creative ways. In Python, we can use the mathematical plus (+) operator to concatenate strings (put two strings together), and the multiplication (*) operator to multiply a string by an integer to duplicate it. We can also use subtraction with dates to find the time between different dates. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:9:3","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Comments and Documentation Comments: Notes from the programmer supplied in-line alongside the code itself, designated in a way that prevents the computer from reading or attempting to execute them as code. [in-line comments (pound/hash mark #) \u0026 block comments] There exist ways of writing comments that can be pulled out to generate separate, standalone documentation. Documentation: Collected and set-aside descriptions and instructions for a body of code. Self-Documenting Code: Code whose variables and functions are named in a way that makes it clear what their underlying content and operations clear to the reader. Supplemental material ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:9:4","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Chapter 2.2: Variables ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:10:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Basic concepts Variables: Alphanumeric (letters and numbers) identifiers that hold values, like integers, strings of characters, and dates. Value: The content of some variable. The variable my_age might hold the value 21. The variable your_name might hold the value “Greymane”. Null: The “value” a variable has when it doesn’t actually have a value. Naming rules: Variables (as well as functions, methods, classes, and other stuff we’ll learn about later) cannot have spaces in them. Variable names can ==only contain letters, numbers, and underscores==. Variable names must ==start with letters==. Technically underscores are also allowed, but we generally only use those in certain situations. Variable names must not duplicate certain ==reserved words==. Names are case sensitive. A good name is ==self-documenting==. See more on this website. Two common conventions are used if the name has more than one word: camel case and underscores. Each programming language has its own accepted style. **In Python, you should use underscores. In Java and C#, you would use camel case**. Other languages have their own conventions. Camel case mushes the words together and capitalizes each word, like this: thisIsMyVariableName. Note that the first letter of a variable’s name is usually in lowercase, while the first letter of a function’s name is often in uppercase. Underscores just replaces spaces with underscores, usually keeping the variable name in all-lower case, like this: this_is_my_variable_name. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:10:1","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Data types Integer, real number, character, string, boolean…self-defined types… See more on this website. In strongly-typed languages, assigning a type to a variable is actually a separate step from assigning a value to the variable; and assigning a different type to this variable will cause crashing. We can multiply a sequence (string, list…) by an integer, and Python just takes that sequence and repeats it however many times we multiplied it by. But we can’t multiply a sequence by a float or a string by a string. Also, when Python is asked to use a boolean like a number (such as multiplying by a boolean), it interprets True as 1 and False as 0. Now, let’s meet a weird guy in Python—the NoneType—which only has one value: None. None is Python’s implementation of the programming concept of ==null== (like the null pointer in C++). This is how Python represents that a variable has no value. This is slightly different from a variable simply not existing: ==the variable name exists, it just doesn’t point to any value==. Because there is no value, it also doesn’t fit into any of the above types. Where Does None Come From? First, the trivial way, we could just do that intentionally. The way it will happen more commonly is that you’ll set it equal to some operation that doesn’t result in anything, like you put on the right of an equal sign a function that has no return value (eg. the print() function) ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:10:2","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Type conversion To treat a certain type of data with operations, functions, or methods of a different data type, we have to use functions for converting between the two. Implicit conversion: In practice, you may not always need to do this manually, though. For example, when you put a value other than a string into Python’s print function, it automatically tries to convert it to a string. When we use comma instead of plus sign, it tells the print statement to interpret each individual thing in the parentheses as a separate piece of data. The print statement ==implicitly converts each thing to a string if needed and then puts them together==. By default, it puts each thing together separated by a space. You’ll receive a ==ValueError== whenever you try to do a type conversion, like float or integer, on a value that can’t actually be converted to that type. ==int(variable)==: Takes as input some variable (usually a string) and attempts to convert it to an integer, returning the integer if successful or raising a ValueError if unsuccessful. This function will work if variable is a string made up only of digits and, optionally, the negative sign. ==bool(variable)==: Takes as input some variable (usually a string) and attempts to convert it to a boolean, returning the boolean value if successful or raising a ValueError if unsuccessful. Generally, this function returns False if variable is 0 or an empty string, True if variable is anything else. ==float(variable)==: Takes as input some variable (usually a string/integer) and attempts to convert it to a float, returning the float if successful or raising a ValueError if unsuccessful. This function will work if variable is a string made up only of digits and, optionally, a negative sign and a decimal point. The computer interprets anything that the user enters by the ==input(variable)== function as a string of characters because it has no way of knowing that it’s a number. So, type conversion is needed under certain circumstances. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:10:3","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Reserved key words in Python import keyword print(keyword.kwlist) Importing Libraries. ==import, from==. Logical Operators. ==and, is, not, or, False, True, None==. Control Structures. ==as, break, continue, if, elif, else, for, in, while, pass, with==. Functions. ==def, return==. Object-Oriented Programming Syntax. ==class==. Error Handling. ==except, finally, raise, try==. The remaining words: ==assert, del, global, lambda, non-local, yield== are outside of the scope of the course. If a reserved word is used as a variable name or a function name, a SyntaxError will be triggered. But if a function name in Python like print is used for a new variable name, assigning value to this variable will not cause any problem, but we’ve hidden the fact that it can also be used as a function. It can only mean one thing for a given block of code, and we’re changing its meaning. When we try to use the word as a function name, a TypeError will arise. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:10:4","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Chapter 2.3: Logical Operators ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:11:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Relational Operators Check the relationships between multiple variables. Numeric Comparison Operators Operators that facilitate numeric comparison between values. Typically, these are ‘greater than’ (\u003e), ‘greater than or equal to’ (\u003e=), ‘equal to’ (==), ‘less than’ (\u003c), and ‘less than or equal to’ (\u003c=). These operators can sometimes be used for comparisons that are not numeric, but that nonetheless have an underlying order: A string of characters is ‘less’ than another string if it comes earlier alphabetically. “Apple” would be ‘less’ than “Banana”. A date is ‘less’ than another date if it comes earlier in time. January 1st, 2017 would be ‘less’ than January 15th, 2017. Non-Numeric Equality Comparisons Nearly any kind of data can compare for equality, even if it isn’t numeric. We can’t ask if an apple is greater than an orange, but we can ask if apples and oranges are ‘equal’, or the same thing. In practice, sometimes this will compare values to see if the values of two variables are the same, and other times it will compare if two variables are pointing to the same data in memory. It could be that two variables have the same values, but those values are stored in separate places, and so the computer doesn’t recognize them as equal. Set Operators Check to see if a value is a member of a set of multiple values. Most often this comes up in strings and lists. With strings, we can check to see if a certain smaller string occurs inside a larger string. For example, “cde” is in the string “abcdefg”, but “ijk” is not. With lists, we can check to see if a certain item is on our list. For example, if we had a list containing “grapes”, “apples”, and “oranges”, then “apples” would be in that set, but “papaya” would not. Relational Operators in Python In many of these examples, we’ll have a logical expression, and we’ll set the result of it equal to a variable. Then, we can check the variable to see what the result of the expression was. We may also print the results of a logical expression directly. Note that a single equal sign (=) is for assignment, while a double equal sign (==) is for comparison. It’s also worth noting that the greater than and less than operators do work for strings as well, and they operate based on sorting the strings alphabetically. Besides, in Python, all capital letters are sorted before all lowercase letters, so a string beginning with a capital Z would be treated as less than a string beginning with a lowercase a. The ==in== operator checks to see if something is contained within a list of other things. For one example, we can use the in operator in the context of strings to see if a certain smaller string is contained within a larger string. Note, the empty string ==\"\"== is in all the strings. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:11:1","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Boolean Operators Operators like “and” and “or” that act on pairs of boolean (true or false) values, or that act on single boolean values, like “not”. They check the combination of multiple relational operators. ==And==: An operator that acts on two boolean (true or false) values and evaluates to “true” if and only if both are true. ==Or==: An operator that acts on two boolean (true or false) values and evaluates to “true” if and only if at least one is true. ==Not==: An operator that acts on one boolean (true or false) value and evaluates to the opposite value (false becomes true, true becomes false). Priority sequence: parentheses → not → and → or Refer to Operator precedence ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:11:2","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Truth Tables Tables that map out the results of a statement in boolean logic (that is, using boolean operators) depending on the values of the individual variables. Properties of Boolean Operators: First, Boolean operators are commutative. What that means is it doesn’t matter what order they come in. ==A and B=B and A== Logical expressions or logical operators are also distributive. ==A and (B or C)=(A and B) or (A and C)== ==De Morgan’s Law #03A9F4==: ==not (A and B)=not A or not B==; ==not (A or B)=not A and not B==. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:11:3","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Extra materials Boolean logic ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:11:4","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Chapter 2.4: Mathematical Operators ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:12:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Appendix 1. Python Translation Guide ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:13:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Print Statements and Line-Ending Behaviors table th:first-of-type { width: 10%; } table th:nth-of-type(2) { width: 40%; } table th:nth-of-type(3) { width: 50%; } Language Syntax Notes Python print(“Here’s a line of code”) print(“Here’s another one!\") By default, print() adds a line break to the end of the printed text. Java System.out.println(“Here’s a line of code”); System.out.println(“Here’s another one!\"); Like Python’s print(), Java’s System.out.println() adds a line break after the printed text. In contrast, System.out.print() will print some text without creating a new line afterward. C printf(“Here’s a line of code”); printf(“Here’s another one!\"); In C, the printf() function does not add a line break after the printed text. To do that, you need to include “\\n” inside the printed text itself, e.g. printf(“New line please!\\n”). C++ std::cout « “Here’s a line of code”; std::cout « “Here’s another one!\"; Like C, C++‘s cout will not add a new line after the printed text. To add one, we would need to write std:cout « “New Line please!\\n”. C# Console.WriteLine(“Here’s a line of code”); Console.WriteLine(“Here’s another one!\"); C#’s Console.WriteLine() function add a line break after the printed text. Like Java, C# also has a Console.Write() function that will write without starting a new line afterward. JavaScript console.log(“Here’s a line of code”) console.log(“Here’s another one!\") By default, console.log() adds a line break to the end of the printed text. VB.NET Console.WriteLine(“Here’s a line of code”) Console.WriteLine(“Here’s another one!\") C# and VB.NET use the same underlying library, so you’ll find that oftentimes syntax like Console.WriteLine is shared between them. Matlab fprintf(“Here’s a line of code); fprintf(“Here’s another one!\"); Like C, Matlab’s fprintf will not add a new line after the printed text. To add one, we would need to write fprintf(“New Line please!\\n”). Swift print(“Here’s a line of code”) print(“Here’s another one!\") By default, print() adds a line break to the end of the printed text. Ruby puts “Here’s a line of code” puts “Here’s another one!” By default, puts adds a line break to the end of the printed text. Scripting languages (Python, JavaScript) generally do not use a semi-colon to mark the ends of lines. Most compiled languages (Java, C, C++, C#) use semi-colons. There are exceptions, though; Swift and VB.NET are a compiled languages that do not use semi-colons, while MatLab is a scripting language that does. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:13:1","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Comment Syntax Python’s comment syntax is in the minority. Language Syntax Notes Python #This is a comment in Python #This is a #multiline comment #in Python Triple quotes can also be used in Python to create multi-line comments. Java //This is a comment in Java /* * This is a * multi-line comment * in Java */ The asterisks at the beginning of each line inside the multi-line comment are customary, but not required. Java, C++, JavaScript, and C# use the same syntax. C /* This is a comment in C*/ /* This is a * multiline comment * comment in C */ The asterisks at the beginning of each line inside the multi-line comment are customary, but not required. C does not have a dedicated single-line comment syntax. C++ //This is a comment in C++ /* * This is a * multi-line comment * in C++ */ The asterisks at the beginning of each line inside the multi-line comment are customary, but not required. Java, C++, JavaScript, and C# use the same syntax. C# //This is a comment in C# /* * This is a * multi-line comment * in C# */ The asterisks at the beginning of each line inside the multi-line comment are customary, but not required. Java, C++, JavaScript, and C# use the same syntax. JavaScript //This is a comment in JavaScript /* * This is a * multi-line comment * in JavaScript */ The asterisks at the beginning of each line inside the multi-line comment are customary, but not required. Java, C++, JavaScript, and C# use the same syntax. VB.NET ‘This is a comment in VB.NET ‘This is a ‘multiline comment ‘in VB.NET VB.NET has no special way of creating multi-line comments. Matlab %This is a comment in Matlab %{ This is a multiline comment in Matlab %} Swift //This is a comment in Swift /* This is a multi-line comment in Swift */ Ruby # This is a comment in Ruby =begin This is a multiline comment in Ruby =end Ruby is weird. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:13:2","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Variable Declarations and Assignments Note that in Python, we create a variable by assigning it an initial value. In other languages, it’s possible to create a variable without assigning it any value. Language Syntax Notes Python my_int = 5 my_str = “Hello world!” Python prefers snake_case for variable style. Java int myVar = 5; string myStr = “Hello world!\"; The first item in the variable declaration line (==int, string==, etc.) is the data type. The variable cannot change types once declared to be a certain type. Java prefers camelCase for variable names. C, C++, C# int myVar = 5; string myStr = “Hello world!\"; The first item in the variable declaration line (==int, string==, etc.) is the data type. The variable cannot change types once declared to be a certain type. C prefers camelCase for variable names. JavaScript var myVar = 5; var myStr = “Hello world!\"; ==var== is used whenever creating a new variable, but it does not represent a type. JavaScript prefers camelCase for variable names. VB.NET Dim MyVar As Integer = 5 Dim MyStr As String = “Hello world!” types (==As Integer, As String==) are optional but recommended in VB.NET. VB.NET prefers camelCase for variable names, but often capitalizes the first letter, too (e.g. ==MyVar== instead of ==myVar==). Matlab my_var = 5 my_str = “Hello world!” Matlab has few consistent variable name styles. Swift var myVar = 5 var myStr = “Hello world!” Swift prefers camelCase for variable names. Ruby my_var = 5 my_str = “Hello world!” Ruby prefers snake_case for variable names. Many languages (Java, C/C++/C#, VB.NET) are statically typed, meaning that once when you create a variable, you have to decide what its type will be. Afterward, it can never take a different type. Other languages (Python, Swift, Ruby, JavaScript) are dynamically typed, meaning that a variable’s type comes from its value. If you change its value, the variable’s type can change. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:13:3","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Operators The rules of logic are generally the same across all programming languages. Python’s operator precedence is relatively universal, although there can be slight differences (for example, not all languages have slicing, subscription, or lambda expressions). The syntax used for various operators, however, can differ. Relational Operators Most relational operators are the same in all languages. These are the same in Python, Java, C, C++, C#, JavaScript, VB.NET, Matlab, Swift, and Ruby: a \u003c b: Less than a \u003c= b: Less than or equal to a == b: Equal to a \u003e= b: Greater than or equal to a \u003e b: Greater than If a and b are not the same type, JavaScript will automatically try to convert them to the same type before comparison. To avoid this conversion, you’d use ===. The languages differ a little bit more with the ‘not equal to’ operator: Language Syntax Notes Python, Java, C, C++, C# a != b  JavaScript a != b  If a and b are not the same type, JavaScript will automatically try to convert them to the same type before comparison. To avoid this conversion, you’d use !==. VB.NET a \u003c\u003e b Technically, the \u003c\u003e operator works in most other languages as well for ‘not equal to’, but != is more common. Matlab a ~= b Boolean Operators The three boolean operators–and, or, not–are generally represented in one of three ways: with symbols, with double-symbols, or with plaintext words. Different languages also use slightly different capitalizations for booleans, so we’ll use the language-appropriate ones here, too. Language Syntax Notes Python True ==and== False #And True ==or== False #Or ==not== True #Not You can also use ==\u0026== (for and) and ==|== (for or) in Python, but they technically do something slightly different. They perform bitwise operations. Java true ==\u0026\u0026== false #And true ==||== false #Or ==!== true #Not true ==^== false #Exclusive-Or You can also use single-operators (==\u0026== or ==|== instead of ==\u0026\u0026== or ==||==), but it’s generally better to use double operators. Double operators only evaluate later conditions if they might change the end result. Java also offers an exclusive-or operator ==^==, which is True if exactly one of the two conditions is True, not both or neither. C 1 ==\u0026\u0026== 0 #And 1 ==||== 0 #Or ==!==1 #Not C does not natively have boolean types: it treats 0 as False and 1 (or any non-zero number) as True. C++, C# true \u0026\u0026 false #And true JavaScript true \u0026\u0026 false #And true VB.NET True And False #And True Or False #Or Not True #Not True Xor False #Exclusive-Or Following its style, VB.NET capitalizes both the boolean values and the logical operators. It also offers an exclusive-or operator. It also includes two additional operators, AndAlso and OrElse, which function like \u0026\u0026 and Matlab TRUE And FALSE #And TRUE Or FALSE #Or Not TRUE #Not TRUE xor FALSE #Exclusive-Or Matlab also offers an exclusive or operator. Swift true \u0026\u0026 false #And true || false #Or !true #Not Ruby true and false #And true \u0026\u0026 false #Also And true or false #Or true || false #Also Or not true #Not !true #Also Not Ruby lets you use either symbols or words. ","date":"2021-10-17","objectID":"/gatech-cs1301xi/:13:4","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"}]