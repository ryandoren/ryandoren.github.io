[{"categories":null,"content":"Intro to Computing in Python by David Joyner","date":"2021-10-30","objectID":"/gatech-cs1301xiii/","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Unit 4 ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:0:0","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Chapter 4.1: Data Structures Data structures are approaches to organizing abstract data types, such that the data can be accessed efficiently. List-Like Structures:Â Also referred to as sequences and collections, a data structure that holds multiple individual values gathered together under one variable name, accessed via indices. This includes structures like lists, arrays, and tuples. Lists are simultaneously a general type of data structure and a specific data type in some languages. Index:Â A number used to access a particular element from a list-like data structure. Traditionally, most programming languages assign the first item of a list-like data structure the index 0. String:Â A data structure that holds a list, or a string, of characters. Lists:Â A data structure that holds multiple individual values gathered together under one variable name, accessed via indices. Similar to arrays and tuples. File Input and Output:Â The complementary processes of saving data to a file and loading data from a file, generally such that the state of the memory of the program is the same after saving and loading have occurred. Dictionaries:Â A data structure comprised of key-value pairs, where a key is entered into the dictionary to get out a value. Similar to or synonymous with Maps, Associative Arrays, HashMaps, and Hashtables. ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:1:0","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Passing by Value vs. Passing by Reference Passing by value: Values themselves being passed back and forth. The functino never knows your variables and you never know the functionâ€™s variables. When passing by value, youâ€™re simply handing off the value and the function canâ€™t actually change your variable. Passing by reference: The function has access to your actual variables and could modify them. You and the function are accessing the same variables. When passing by reference, youâ€™re handing the variable itself to the function and the function can modify the variable if it wants. The difference between passing by value and passing by reference comes down to whether or not you want the function to be able to change the values of the variables directly, or if you simply want it to receive the values themselves without being able to access the variables. (whether the function has the direct access to your original filesğŸ“•) In some languages like C++, you can choose whether to pass a variable by value or by reference. However, Python deals with passing-by-value and passing-by-reference a little strangely. In reality, everything is passed by reference, but some primitive data types like integers often appear to be passing by value. This is due to mutability. ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:1:1","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Variable Assignments When we type down an assignment statement b = a, did we assign a only to the current value of b or does b follow a around and copy its value whenever it changes? In other words, did we tell b you now equal the current value of a or did we tell b you should always equal a? \u003e\u003e\u003e a = 5 \u003e\u003e\u003e b = a \u003e\u003e\u003e a = 7 a = 7, b = 5 \u003e\u003e\u003e a = [\"One\", \"Two\", \"Three\"] \u003e\u003e\u003e b = a \u003e\u003e\u003e a.append(\"Four\") a = [\"One\", \"Two\", \"Three\", \"Four\"], b = [\"One\", \"Two\", \"Three\", \"Four\"] There are two important takeaways here: We can refer to the same data by different namesâ€“ we can have multiple variables that point to the same data and if you access and modify the data via one variable name, it also modifies the data for any other variable names that point to the same data. As with our function calls, we see that integers and lists behave differently. An integer will not keep its data up to date if the variable to which it is set changes, but thatâ€™s not the case for a list. Again, this comes down to mutability. ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:1:2","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Mutability in Python Mutability:Â Whether or not a variable can have its value changed after being declared. Mutable Variable:Â A variable whose value can change after it has been declared. Immutable Variable:Â A variable whose value cannot change after it has been declared. Python passes all arguments by reference. But for all practical purposes, some data types seem to be passed by value. The reason they acted this way is because they were immutable. Letâ€™s talk about the way Python actually does this. We have a variable called myInteger, and we assign it the value 1, weâ€™re telling it to point to a place in memory that stores the number 1. When we use myInteger, weâ€™re actually looking up its value. Now when we say myInteger equals 2, what Python does is kind of weird. It grabs a new area of memory, puts the number 2 there, and tells myInteger to point out that new location instead of the old location. What that means is that the old value is still there in memory. The value didnâ€™t change. We didnâ€™t change the number 1. Instead, we just created a new place in memory and told myInteger to point to that instead. Changing the value of myInteger changes the spot in memory that it points to, but it doesnâ€™t actually change the value stored in the original spot of memory. Note that a function canâ€™t change what value the variable used in the main program is pointing to. It can only change the value its own copy of that variable is pointing to. (Because the scope of variables defined in the function were until the function ended.) The computer has to have some way of identifying the location in memory that stores the data. Multiple names or different names can point to the same place in memory, so the place memory really needs a fundamental unchangeable name. This is called a memory address. It tells the computer where to find a particular value for a particular variable name. print(id(variable/value)) # Printing Memory Addresses Immutable data types: integers, float, strings (Changing them changes the address where they can be found, seem like passing by value.) Mutable data types: lists (Changing them does not change the address where they can be found. note that itâ€™s changing/modifying them, not reassigning them to a whole new value.) Immutable variables pointing to the same value have the same id; however, for mutable variables, even they point to the same value, they have different ids, enless they are connected by = ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:1:3","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Functions vs. Methods Methods are functions accessed through dot notation; they are functions contained within data types. Just like functions, methods can return certain types of data as well. str.isdigit() # a Boolean method, check to see if a string represents a number, returns either a true or a false value str.isupper() # a Boolean method, check to see if all the letters in the string are uppercase, returns either a true or a false value ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:1:4","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"External Materials ğŸBasic Data Structures ğŸPython Data Structures ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:1:5","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Chapter 4.2: Strings ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:2:0","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Basic Concepts String:Â A data structure that holds a list of characters. Character:Â A single letter, number, symbol, or special character. Unicode:Â A computing industry standard that sets what hexadecimal codes correspond to what characters, so that text appears consistent across platforms. (263A should be a simple smiley emoji ğŸ˜Š) Hexadecimal:Â A short-hand expression of the ones and zeroes that comprise computer data, comprised of 16 characters, 0 through 9 and A through F. Special Characters: Tab, Newline characters (carriage returns \u0026 line feed) Newline Character: A Unicode character, either LF (line feed) or CR (carriage return), that is rendered as the beginning of a new line of text. (Mac uses LF to represent its newline while Windows uses both LF and CR.) ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:2:1","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Declare Strings Python wonâ€™t terminate the string until it encounters the same mark that you used to start the string ',''',\". When a string is declared with triple quotation marks or triple apostropheâ€™s, everything inside them will be interpreted as part of the string. s = '''123 456''' ---------- 123 456 ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:2:2","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"String Concatenation and Slicing Concatenation: use plus operator. Sliceing: Remember that string is a kind of list, so we can use string[start:end][start, end) to slice strings (a positive number counts from the beginning, a negative number counts from the end.). Remember also, strings are an immutable type. That means we canâ€™t modify their values. We can only use to access individual characters but not modify them. ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:2:3","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"String Searching The in operator can be used with strings to check if a substring is part of a string. The find method string.find(text, [start], [end]) is a member of the string type, and it takes as input the substring we want to find. It returns the first index where that substring was found or -1 if it wasnâ€™t found anywhere. We can use a while loop to get all the indices that the targeted substring has appeared. myString = \"ABCDEEDGHYRCDELKCDEJNCECDEGGHEDCDEPJ\" findString = \"CED\" currentLocation = 0 while currentLocation \u003e= 0: print(findString, \"found at\", currentLocation) currentLocation = myString.find(findString, currentLocation+len(findString)) If we just care about how many times the targeted substring has appeared in the given string, we can use the count method. The count method will count the number of times the string in parentheses occurs inside the string calling count. myString.count(findString, [start], [end]) ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:2:4","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Other Useful String Methods ğŸString Methods at Python.org string.split([separator]) The split method divides the string calling it into several substrings based on the separator character and returns to a string list. The default separator is space. If we use period as the separator, every sentence except the first will start with an empty space. Second, there will be an empty string at the end, because Python sees the period at the end of the string, and at that point, it closes off the previous string and starts a new one. It doesnâ€™t know that itâ€™s not going to find anything in that new one. And so we end up with an extra empty string at the end of our list. The solution is to use period space ', ' as the separator. string.capitalize() capitalizes the string string.lower() all-lowercase version string.upper() all-uppercase version string.title() capitalizes any character found after a space string.strip([character]) strips out any whitespace before or after the string. We could also supply an argument to strip, to strip out a different character. But if we donâ€™t, it assumes to strip out spaces. string.replace(string1, string2) replaces string1 with string2 string.join(list) uses the string calling the join method to concatenate each item from the list of strings Split and join are basically reverses of each other. Notice that string methods do not actually change the value of the string. They just return what would be the value if that operation was applied. To actually save it, we would have to define antoher string and assign the return value of the string method to that newly defined string. ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:2:5","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"External Materials ğŸ Strings from How to Think Like a Computer Scientist ğŸPython Strings from Google for Education A string literal can span multiple lines, but there must be a backslash \\ at the end of each line to escape the newline. String literals inside triple quotes, \"\"\" or â€˜'â€™, can span multiple lines of text. Enclose the whole expression in an outer set of parenthesis â€“ then the expression is allowed to span multiple lines. ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:2:6","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Chapter 4.3: Lists ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:3:0","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Basics List-like Structures:Â Also referred to as sequences and collections, a data structure that holds multiple individual values gathered together under one variable name, accessed via indices. It would encompass other data structures like dictionaries and maps. Homogeneity: A property of lists determining whether they can accept multiple types of variables. A homogenous list can only accept one type of variable; a nonhomogenous or heterogenous list can accept multiple types. Nearly every programming language has some concept of a list, but the terminology and the specific details differ significantly. One major way different languages differ in their implementations of lists is mutability. Mutability of a list involces: whether the values of the list can be changed whether the size of the list can be changed Some list implementations will allow us to append new items to the end, while others require you to state in advance how many items can fit in the list. Generally, the latter is more common for lower level languages like C where we manage memory more deliberately. Another major way list-like structures may differ is whether they accept multiple data types. This is called homogeneity and lists. In some list implementations, every item in a list must be the same type. Other languages donâ€™t have this restriction. A list is a data structure that contains multiple values accessed via an ordered numerical index. This is in contrast to dictionaries and hash tables and other data structures. They can also contain multiple values, but they can be accessed via non-numeric indices. List-like structures can go by various different names like lists, arrays, tuples, vectors, tables, and more. Oftentimes, array is used to refer to a more primitive structure that only supports changing the existing values, whereas list refers to more complex data structures that support sorting and inserting and other operations. Tuples are, most often, immutable. ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:3:1","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Tuples in Python ğŸ Documentation on tuples from Python.org. Tuple:Â An immutable form of a list-like structure in Python. Like strings, we canâ€™t add values to the end of a tuple and we canâ€™t change the current values of anything inside the tuple or sort them. Lists:Â A mutable form of a list-like structure in Python. Declare a tuple: tuple = (value1, value2, value3) Tuples can have multiple data types within them. This follows Pythonâ€™s general procedure of being what we call loosely typed. Python never really cares about what data types youâ€™re using until you try to do something that you canâ€™t do, like multiplying a string by a float, or printing the length of an integer. Tuples can be accessed and sliced as other list-like data structures. However, they also have a fancy little syntax for unpacking: (variable1, variable2, variable3) = tuple What this does is it one by one assigns the values of the tuple to the different variables contained on the right side of this assignment statement. The most usefulness of tuples may be functions. Generally functions can only return one variable or one value. But since tuples can pack multiple values into just one, they in some way let us return multiple values out of a function: def function(args): function body return (value1, value2, value3) # return a tuple allows a function to return multiple values (variable1, variable2, variable3) = function(args) # assignment using tuple unpacking Tuples can be nested. You can have a tuple of tuples. How to access an individual value inside of a nested tuple: use two sets of brackets. tuple[num1][num2] The first one specifies which tuple we want and the second one specifies which value from that tuple we want. ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:3:2","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Lists in Python ğŸDocumentation on lists from Python.org. Everything weâ€™ve seen in the past with both strings and tuples can also be used for lists. The only real difference is that whereas we define a string with quotation marks and a tuple with parentheses, we define a list with brackets. (access, slice, unpacking, function return, nestedâ€¦) What differentiates lists is that theyâ€™re mutable. That means we can change their values. We can add values to them, we can remove values from them, we can change the current value of certain values in the list. We can reorder them. list.sort() # A method inside the list data type and sorts the values according to some internal logic. For integers it just sorts from the lowest to the highest (ascending). list.reverse() # reverses the current order of the list, not necessarily the sorted order of the list. list1.extend(list2) # takes the values of list2 and puts them at the end of list1. list.insert(location, value) # inserts an item at a certain place in the list. list.remove(value) # removes a certain value. del list[] # deletes items by location in the list. list.pop([index=-1]) # removes the last item (by default) of the list and returns it, index is optional. list.index(value) # finds the index of a certain value. list.count(value) # counts how many times a certain value appears. list.copy() # returns a shallow copy of the list. Equivalent to a[:]. list.clear() # removes all items from the list. Equivalent to del a[:]. Itâ€™s important to note that calling the method actually changes the value of the list. Remember, when we called methods on strings they didnâ€™t change the value of the string. Thatâ€™s because lists are mutable, and strings are immutable. The sorted(list) function can also be used for sorting, but it does not change the value of the original list. It can be applied to any Iterable object, which means that it also accepts strings, sets, dictionaries when they are passed to it. Difference between .extend() and .append(): extend(), on the one hand, takes an iterable (list, set, tuple or string), and adds each element of the iterable to the list one at a time. append(), on the other hand, adds its argument to the end of the list as a single item, which means that when theÂ append()Â function takes an iterable as its argument, it will treat it as a single object. extend()Â is a more efficient version of callingÂ append()Â multiple times. Lists are mutable. That means if we pass a list to a function or method and change the values of the list, those changes will persist out to our main program. So when dealing with lists, or any other mutable data type, we have to be careful to understand that all modifications we make to the list will persist. ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:3:3","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Lists vs. Tuples Generally, though, there are a couple conventions we follow to decide whether to use lists or tuples: We often use tuples when weâ€™re definitely dealing with a pre-determined number of items. We use lists when the ability to add or remove from the list would actually be useful and relevant. We usually use lists when the individual things on the list are qualitatively similar. We use tuples if theyâ€™re qualitatively different. Lists are used for alike data types by convention because we tend to execute the same body of code for each item in the list. Tuples are more often used to represent information thatâ€™s unpacked into unique variables, those have qualitatively different meanings. And so youâ€™re not going to just run some code on every item in a tuple. For that same reason, itâ€™s more normal for tuples to have different data types within them because weâ€™re not generally expecting to be able to iterate over a tuple in the same way. If youâ€™re defining a constant set of values and all youâ€™re going to do with it is iterate through it, use a tuple instead of a list. It will be faster than working with lists and also safer, as the tuples contain â€œwrite-protectâ€ data. ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:3:4","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Convert A List Toâ€¦ You convert a list to a string by usingÂ ''.join(). This operation allows you to glue together all strings in your list together and return them as a string. NoteÂ that if your list only contains integers, you should convert the elements to strings before performing the join on them. Read moreÂ here. You can change a list to a tuple in Python by using theÂ tuple()Â function. Pass your list to this function, and you will get a tuple back! You can change a list into a set with theÂ set()Â function. Just pass your list to it! But remember, a set is an unordered collection of unique items. That means not only means that any duplicates that you might have had in your original list will be lost once you convert it to a set, but also the order of the list elements. A dictionary works with keys and values, so the conversion from a list to a dictionary might be less straightforward. You will need to make sure that elements are interpreted as key-value pairs. The way to do this is to select them with the slice notation and pass them toÂ zip(keys, values) (keys/values=list[startğŸ”šstep]) which zips elements together. ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:3:5","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Clone Or Copy A List There are a lot of ways of cloning or copying a list: You can slice your original list and store it into a new variable:Â newList = oldList[:] You can use the built-inÂ list()Â function:Â newList = list(oldList) You can use theÂ copyÂ library: With theÂ copy()Â method:Â newList = copy.copy(oldList) If your list contains objects and you want to copy those as well, you can useÂ copy.deepcopy():Â copy.deepcopy(oldList) NoteÂ that when you use the â€˜simpleâ€™ copy (shallow copy) methods and has modified the copied list, if the modification is done to the first layer, then nothing would be changed to the original list; but if the modification is done to a deeper layer, the original list would also be modified. In contrast, if you use theÂ deepcopy()Â method, nothing of the original list will be change whatever modification has been done to the copied list. import copy as c objectList1 = ['a','b',['ab','ba']] objectList2 = ['a','b',['ab','ba']] shallowCopiedList = objectList1[:] deepCopiedList = c.deepcopy(objectList2) shallowCopiedList[0] = 'c' deepCopiedList[1] = 'd' shallowCopiedList[2][0] = 'cc' deepCopiedList[2][1] = 'dd' print(objectList1) print(objectList2) ---------- ['a', 'b', ['cc', 'ba']] ['a', 'b', ['ab', 'ba']] ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:3:6","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"List Comprehension List comprehension is, basically speaking, a way of elegantly constructing your lists. myList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] [x**2 for x in range(10)] [x**2 for x in range(10) if x%2==0] [(lambda x: x*x)(x) for x in myList] # anonymous function (lambda x: x*x)(x) is like f(x) [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y] [[row[i] for row in matrix] for i in range(4)] # Counting all items in a list with count() list= [\"a\",\"b\",\"b\"] [[x,list.count(x)] for x in set(list)] # Counting all list items with Counter() from collections import Counter list = [\"a\",\"b\",\"b\"] Counter(list) # Counter() is generally faster when you want to count all list items. ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:3:7","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Split A Python List Into Evenly Sized Chunks To split your list up into parts of the same size, you can resort to theÂ zip()Â function in combination withÂ iter(): x = [1,2,3,4,5,6,7,8,9] y = zip(*[iter(x)]*3) # Split x up in chunks of 3 list(y) # Use list() to print the result of zip() ---------- [(1, 2, 3), (4, 5, 6), (7, 8, 9)] ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:3:8","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Stacks: LIFO Structures â€œLast-In-First-Outâ€ (LIFO) paradigm. We can only access the most recently-added (newest) item on the list; We can only access it by removing it from the list. E.g., putting dishes in the sink one on top of the other as they get dirty, then washing them when the sink gets full. stack=[value1, value2, value3] stack.append(value4) stack.pop() ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:3:9","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Queues: FIFO Structures â€œFirst-In-First-Outâ€ (FIFO) paradigm. We can only access the least recently-added (oldest) item on the list; We can only access it by removing it from the list. queue=[value1, value2, value3] queue.append(value4) queue.pop(0) ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:3:10","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Linked List A list-like structure where the location of each item in the list is contained in the previous item in the list. In a list, each spot tends to be a reference to a particular spot in memory that might be completely disconnected to the other ones. In effect, each spot in the list is more like an individual variable name that could point to anywhere in memory. In a linked list, on the other hand, it only has one item that points to a place in memory. The first one. What would make it unique is that instead of the second spot pointing to the second address, it would be data contained in the first spot that point to the second address. Each value of the list contains the location of the next value of the list. E.g., going on a scavenger hunt where each clue features a puzzle you must solve to find the next clue. ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:3:11","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"External Materials ğŸ Lists from How to Think Like a Computer Scientist ğŸPython Lists from Google for Education ğŸPython List Examples â€“ Insert, Append, Length, Index, Remove, Pop from The Geek Stuff ğŸ18 Most Common Python List Questions Note that, as youâ€™re working with hashable items, checking membership (testing whether a certain element is part of your sequence) will go faster with sets than with lists. Hashable Non-Hashable Floats Dictionaries Integers Sets Tuples Lists Strings Â  frozenset() Â  # Flatten a list sum(list, []) print([item for sublist in listOfLists for item in sublist]) # Obtain the intersection of two lists intersection = [list(filter(lambda x: x in list1, sublist)) for sublist in list2] intersection = [[x for x in sublist if x in list1] for sublist in list2] # If the order of your elements is not important and if you donâ€™t need to worry about duplicates then you can use set intersection: list(set(list1) \u0026 set(list2)) list(set(list1).intersection(list2)) ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:3:12","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Chapter 4.4: Dictionaries Dictionaries:Â A data structure comprised of key-value pairs, where a key is entered into the dictionary to get out a value. Similar to or synonymous with Maps (a collection of keys mapped to values; Java, C++), Associative Arrays (PHP, JavaScript), and HashMaps/Hashtables (The term hash refers to the way in which the data structure is constructed). A dictionary would preserve the ability to give names to multiple values by way of keys. Dictionary Key:Â A value then, when passed into a dictionary, returns a corresponding value, like a word and its definition. Similar to a variable. Dictionary Value:Â A value returned in response to a key in a dictionary. Similar to a value of a variable outside a dictionary. The major difference between a dictionary and a list is that the values of the list had to be accessed via numeric identifiers called indices or indexes. But dictionaries use keys instead of numeric indices/indexes. Besides, dictionaries arenâ€™t guaranteed to preserve order. In a list, the first item is guaranteed to be the first item unless itâ€™s changed; in a dictionary, the first key-value pair added might not be the first one accessed. ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:4:0","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Dictionaries in Python We use [brackets] for lists, (parentheses) for tuples, {curly braces} for dictionaries. Each key/value pair in our dictionary is defined with a syntax key colon value. With a dictionary, weâ€™re bundling up multiple variables, but we retain the ability to give them each their own name. Note that when we print the dictionary that weâ€™re defining, it actually prints in a different order than the way we defined it. Dictionaries carry no guarantee that the keys and values will be printed in the same order in which they were defined. It only guarantees that each value will stick with the correct key. The persistence of keys, though, means that in a dictionary, keys must be immutable values. So we can use strings, integers, floats, tuples as keys, but we couldnâ€™t use a list or a dictionary as a key because those are mutable data types. The reason for this is that if the key changes, the dictionary wouldnâ€™t know what value was associated with it. So it must guarantee that the keys cannot change. Values, on the other hand, can change. Editing a Dictionary: dictionary['newKey'] = newValue del dictionary['targetKey'] if keyName in dictionary: # check whether a key is in the dictionary # traverse every item in the dictionary for value in dictionary.values(): # iterate over the values directly when not caring about keys; dictionary.values() returns a list of all the values in that dictionary for key in dictionary.keys(): # iterate over the keys when caring about values and their corresponding keys; dictionary.keys() returns a list of all the keys in that dictionary value = dictionary[key] for (key, value) in dictionary.items(): # iterate over each tuple corresponding to a key and a value; dictionary.items() returns a list of (key, value) tuples in that dictionary ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:4:1","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Dictionary Applications A dictionary of dictionaries: having names as our keys, having the value be another dictionary. And then the values for each key in that dictionary correspond to the type of data. This is getting very close to the idea of objects. Word Count: myString = \"This is the string whose words we would like to count. This string contains some repeated words, as well as some unique words. It contains punctuation, and it contains words that are capitalized in different ways. If the method we write runs correctly, it will count 4 instances of the word 'it', 3 instances of the word 'this', and 3 instances of the word 'count'.\" myString = myString.replace(\".\",\"\") #Remove periods myString = myString.replace(\",\",\"\") #Remove commas myString = myString.replace(\"'\",\"\") #Remove apostrophes myString = myString.lower() #Make all lower case mySplitString = myString.split() #Split by spaces wordDictionary = {} #Create empty dictionary for word in mySplitString: #For each word in the split string if word in wordDictionary: #If it's already been found... wordDictionary[word] += 1 #Add one to its count else: #Otherwise... wordDictionary[word] = 1 #Create it with value 1 print(wordDictionary) Arrange seating chart for a wedding seatingChart = {\"David\" : 3, \"Lucy\" : 3, \"Dana\" : 2, \"Addison\" : 2, \"Vrushali\" : 1, \"Bilbo\" : 3, \"Sara\" : 1, \"Lugos\" : 1, \"Mireia\" : 1, \"Partha\" : 2, \"Venijamin\" : 1, \"Terra\" : 2, \"Tryphon\" : 3, \"Gevorg\" : 1, \"Raza\" : 3, \"Rein\" : 3, \"Sofia\" : 2, \"Perle\" : 2} #For each name, table pair in the seating chart for (name, table) in seatingChart.items(): #Print the table for the name print(name, \" is seated at table #\", table, sep=\"\") print() #For each table number for i in range(1, 4): print(\"The guests at table #\", i, \" are: \", sep=\"\", end=\"\") #For each name, table pair for (name, table) in seatingChart.items(): #If the table numer is this number if i == table: #Print the name print(name, end=\" \") print() Classroom roster: lists as values classes = {\"Math\" : [\"David\", \"Lucy\", \"Dana\"], \"Physics\" : [\"Addison\", \"Vrushali\", \"Bilbo\"], \"Chemistry\" : [\"Sara\", \"Lugos\", \"Mireia\", \"Perle\"], \"Computing\" : [\"Partha\", \"Venijamin\", \"Terra\", \"Sofia\"], \"History\" : [\"Tryphon\", \"Gevorg\", \"Raza\", \"Rein\"]} print(\"Students in Computing:\", classes[\"Computing\"]) #Add Francis to History classes[\"History\"].append(\"Francis\") print(\"Students in History:\", classes[\"History\"]) Address book: lists/tuples as values (has to know the indexes of address, phone number, and email) addressBook = {\"David\": (\"555 Home St\", \"4045551234\", \"david@david.com\"), \"Lucy\" : (\"555 Home St\", \"4045555678\", \"lucy@lucy.com\"), \"Dana\" : (\"123 There Rd\", \"4045559101\", \"dana@dana.net\")} print(\"David's Information:\", addressBook[\"David\"]) print(\"Dana's Phone Number:\", addressBook[\"Dana\"][1]) # Knowing that the phone number is at index one Address book: dictionaries as values (refer to these individual values by keys instead of by indices) addressBook = { \"David\": {\"address\" : \"555 Home St\", \"phone\" : \"4045551234\", \"email\" : \"david@david.com\"}, \"Lucy\" : {\"address\" : \"555 Home St\", \"phone\" : \"4045555678\", \"email\" : \"lucy@lucy.com\"}, \"Dana\" : {\"address\" : \"123 Here Rd\", \"phone\" : \"4045559101\", \"email\" : \"dana@dana.net\"}} print(\"David's Information:\", addressBook[\"David\"]) print(\"Dana's Phone Number:\", addressBook[\"Dana\"][\"phone\"]) Grading students' answer sheets ANSWER_KEY = {\"1\" : \"A\", \"2\" : \"B\", \"3\" : \"C\", \"4\" : \"D\", \"5\" : \"A\"} students={} students[\"David\"] = {\"1\" : \"A\", \"2\" : \"B\", \"3\" : \"A\", \"4\" : \"B\", \"5\" : \"C\"} students[\"Terra\"] = {\"1\" : \"A\", \"2\" : \"B\", \"3\" : \"C\", \"4\" : \"D\", \"5\" : \"A\"} students[\"Lugos\"] = {\"1\" : \"A\", \"2\" : \"C\", \"3\" : \"C\", \"4\" : \"D\", \"5\" : \"A\"} #For each student and their answers for (student, answers) in students.items(): grade = 0 #Start grade at 0 #For each question and answer for (question, answer) in answers.items(): #If the answer matches ANSWER_KEY's answer... if answer == ANSWER_KEY[question]: grade +=1 #Increment their grade #Create a new key","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:4:2","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"External Materials ğŸDictionaries from How to Think Like a Computer Scientist ğŸ20. Dictionaries from How to Think Like a Computer Scientist: Learning with Python 3 ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:4:3","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Chapter 4.5: File Input and Output File Input and Output:Â The complementary processes of saving data to a file and loading data from a file, generally such that the state of the memory of the program is the same after saving and loading have occurred. Each file type has its own built-in, type-specific encoding. That encoding is properly unpacked by a program that knows how to read the file. File types set up rules for how to interpret a file, and a program can only correctly interpret the file if it knows those rules. Many languages actually require that file input and output be enclosed within a try block. Reading simply means that weâ€™re looking at the fileâ€™s contents and reading it into our program. Weâ€™re not changing the contents, just inputting it into our own code. Writing, on the other hand, means weâ€™re rewriting the file from scratch. When we write to a file, we, by default, erase it and rewrite it completely from scratch. With writing, we assume the file is a snapshot of the current state of our data, not a running log of the history of all of its changes. Appending also writes to the file, but it starts on the very last line of the file. Nothing is overwritten. New data is just added to the end. ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:5:0","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Writing Files in Python outputFile = open(\"OutputFile.text\", 'w') # w-write, r-read, a-append; Write will overwrite the current content of the file, append will add to the end of the file, and read will just read from the file without actually changing its contents. outputFile.write(string) # the write method can only write strings to files. By default write does not start a new line at the end of writing a particular line. outputFile.writelines(list) # takes as input a list of strings and automatically writes them to the file; doesn't append spaces or new line characters to the end of each item in the list.So, one solution would be: outputFile.writelines('/n'.join(list)) print(content, file = outputFile) # If we supply an argument for the keyword 'file' when calling our print function, then Python will write to that file instead of to the console. outputFile.close() ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:5:1","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Reading Files in Python Remember when loading from a file, the computer by default interprets everything as text. If we need to treat it as numbers or some other kind of data, weâ€™ll need to perform a type conversion. inputFile = open(\"OurtputFile.txt\", 'r') print(inputFile.readline()) # if we want to delete the newline character of each line, use print(inputFile.readline().strip()) myInt = int(inputFile.readline()) # loading into lists for line in inputFile: # starts from the line that has not been read myList.append(line.strip()) inputFile.close() ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:5:2","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Save and Load Functions #Saves inList to the file def save(filename, inList): outputFile = open(filename, \"w\") for item in inList: print(item, file = outputFile) outputFile.close() #Loads from filename and returns a list of the contents def load(filename): inputFile = open(filename, \"r\") inList = [] for line in inputFile: inList.append(line.strip()) inputFile.close() return inList myList = [\"David\", \"Lucy\", \"Vrushali\", \"Ping\", \"Natalie\", \"Dana\", \"Addison\", \"Jasmine\"] save(\"OutputFile.txt\", myList) newList = load(\"OutputFile.txt\") print(newList) ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:5:3","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"External Materials ğŸFiles from How to Think Like a Computer Scientist ","date":"2021-10-30","objectID":"/gatech-cs1301xiii/:5:4","tags":null,"title":"Gatech CS1301xIII.md","uri":"/gatech-cs1301xiii/"},{"categories":null,"content":"Intro to Computing in Python by David Joyner","date":"2021-10-25","objectID":"/gatech-cs1301xii/","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":" â€œAlways code as if whoever ends up maintaining your code will be a violent psychopath who knows where you live.â€ -Martin Golding ğŸ˜‚ğŸ˜‚ğŸ˜‚ğŸ˜‚ğŸ˜‚ğŸ˜‚ğŸ˜‚ğŸ˜‚ğŸ˜‚ğŸ˜‚ğŸ˜‚ğŸ˜‚ Fine. Unit 3 ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:0:0","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Chapter 3.1: Basics of Control Structures Control Structures:Â Statements that control the flow of execution of the program. Or, more simply, lines of code that control when other lines of code run. They allow us to loop over certain lines of code multiple times, changing the data that they act on each time. Conditional Statements: Programming statements that control what code is executed based on certain conditions; usually of the form â€œifâ€, â€œelse ifâ€, and â€œelseâ€. Loop:Â A programming control structure that executes a segment of code multiple times. Function:Â A segment of code that performs a specific task, sometimes taking some input and sometimes returning some output. (Eg. purchasing something is a common behavior regardless of what youâ€™re buying. The steps are always the same: get the total, swipe or insert your card, enter your PIN, sign your name, and remove the card. So, we can imagine grouping those actions together into a common function to use.) Exception:Â An error that a program might want to anticipate and catch instead of outright avoiding. Exception Handling:Â A control structure that catches certain anticipated errors and reacts to them accordingly. Condition vs. Exception: Conditionals are most often decisions when the computer has access to all the necessary information. The condition is intentionally checked. Exception handling also feels like a decision, but typically exception handling occurs when we didnâ€™t check some piece of information beforehand. (Eg. we donâ€™t usually check for an insufficient balance, but it could occur.) Indentation:Â Spaces at the beginning of a line that are used to group together blocks of code. All consecutive lines of code at the same level of indentation are in a single code block. Scope:Â The portion of a programâ€™s execution during which a variable can be seen and accessed. Similar to a computerâ€™s short-term memory. A single variable usually lives within the control structures definition. And once the computer leaves that control structure, the variable is lost. So the code that runs after the conditional canâ€™t see any variables that were created inside of it. The reason is that the computer canâ€™t guarantee that the contents of a conditional statement actually ran. ğŸ§ Note that in Python, a variable created in a control structure lives since the line it is created (and run) to the end of the code, which is a bit wierd though. ğŸ¤” In other languages like Java, for example, if you define a variable inside a conditional, then the variable ceases to exist when the condition is done. ğŸ˜“ ğŸ¤“So, itâ€™s better to never create variables inside a conditional that will need to be accessed outside the conditional. Functions define scope even more narrowly. A function scope is generally just a variable sent to it or created within it. Functions donâ€™t automatically see anything created before their run. They only see those things that are sent into them intentionally. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:1:0","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Chapter 3.2: Conditionals Conditional Statements:Â Programming statements that control what code is executed based on certain conditions; usually of the form â€œifâ€, â€œelse ifâ€, and â€œelseâ€. If-Then Statement:Â A conditional control structure that runs a block of code only if a certain condition is true. if Else Statement:Â A conditional control structure that runs a block of code if all preceding if-then and else-if statements have been false. else Else-If Statement:Â A conditional control structure that runs a block of code if all preceding if-then and else-if statements have been false and some other conditions are met. elif Nested Conditional:Â A conditional statement that is itself controlled by another conditional statement. More simply, an if-then statement within another if-then statement. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:2:0","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Chapter 3.3: Loops For Loop:Â A loop control structure that runs a block of code a predetermined number of times. For loops run with some advanced knowledge about how many times the loop will run. However, this number can be a variable (eg. a user input), just make sure that it is defined before the for loop. For-Each Loop:Â A loop control structure that runs a block of code a predetermined number of times, where the number of times comes from the length of some list and the items in the list are automatically loaded into a variable for usage in the block of code. Iterate:Â To repeat code a number of times. Iteration:Â A single execution of a repeated task or block of code. While Loop:Â A loop control structure that runs a block of code until a certain logical expression is not satisfied. They run while something remains true. Anything we can express in a for loop can also be expressed in a while loop. But not all loops are interchangeable. For loops must have some pre-knowledge about the number of times it should run. Some languages also have a special kind of while loop called a do while loop. We can think of the standard while loop that we talked about before as a while do loopâ€“while a condition is true, do something. A do while loop is identical except that it guarantees the something will be run at least once. It does it before checking the condition the first time. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:3:0","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"For Loops Loop Control Variable: A variable whose value is the number of times a loop has run. It is used to check if the loop should keep running (e.g. if it has run as many times as itâ€™s supposed to). We actually canâ€™t change the variable within the loop. Nothing we do to that variable inside the body of this loop will be carried over to the next time that loop runs. No matter what has been done with the variable within the body of the loop, it will take the next value in the list. Actually, in Python, every for loop is a for-each loop. It runs the indented code for each item in the list given. In a for loop, range() is used so that you know exactly how many iterations have occurred, but you have to manually look up each item by its index. In a for-each loop, a pre-defined list is used, you iterate directly over the items, but you have to use other ways to get the index (list.index(value)). ğŸ“•When weâ€™re just printing, weâ€™ll sometimes just use commas instead, and then we donâ€™t have to worry about actually converting an integer into a string. But input is a different function. Itâ€™s not the print function, and it doesnâ€™t know how to put together variables the same way as our print function does. So, here, if we want to use a variable that holds an integer in the prompt that we give to our user, we have to explicitly convert it to a string. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:3:1","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"While Loops While loops are good for code where we donâ€™t know how many times we need to repeat in advance. Infinite loopâ€“a loop that, because of the way itâ€™s designed, never stops running. Useful for game design. For loops cannot be infinite loops (even we use â€˜Infiniteâ€™ to create a range, because â€˜Infiniteâ€™ is just a large constant). Although we canâ€™t do a do-while loop in Python, we can create our initial variables and assign values to our variables such that it guarantees the while loop will run at least once. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:3:2","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Advanced Loop Keywords continue: Skip the rest of the current iteration of the loop andÂ continueÂ with the next iteration of the loop (if there is a next iteration). If this for loop was actually nestedâ€“ if it was inside of another for loopâ€“ continue will correspond to the closest for loop. break: Skip the rest of the current iteration of the loop andÂ breakÂ out of the loop altogether, skipping any later iterations, too. Break forces execution to skip to the next line of code after this loop. pass: Pass is just like Pythonâ€™s way of leaving a blank indented line. It breaks the requirement that control structures must have code within them and skip the body of the control structure. Pass exists because there will be certain rare times when we need to use a control structure, but we donâ€™t want to do anything inside of it. One example might beâ€“ imagine we know weâ€™re going to want to loop somewhere, but we havenâ€™t implemented its contents yet. We want to leave the loop there for now, but we donâ€™t want to bother with the interior of it. We could use pass just to skip over the inside of that loop for now until we come back to implement it. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:3:3","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Extra materials ğŸBeginning Python Programming for Aspiring Web Developers ğŸHands-on Python 3 Tutorial ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:3:4","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Chapter 3.4: Functions Function Call: A place where a function is actually used in some code. Function Definition:Â A segment of code that creates a function, including its name, parameters, and code, to be used by other portions of a program. Function Header:Â The name and list of parameters a function expects, provided as reference to the rest of the program to use when calling the function. Function Body:Â The code that a function runs when called. Return Statement:Â The line of code that defines what output will be sent back at the end of a function. Not all functions and all languages have return statements. Some might not need to return in the output of the main program. Similarly, not all functions require any input. Parameter:Â A variable for which a function expects to receive a value when called, whose scope is the functionâ€™s own execution. Arguments:Â Values passed into parameters during a function call. Essentially, these are the values assigned to the functionâ€™s dedicated variables (i.e., parameters). Parameters are like variables, and arguments are like values. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:4:0","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Define a Function Note that when Python runs the code, it doesnâ€™t initially run the function body. The header of the function definition loads into the computerâ€™s memory the knowledge that there exists a function defined on that line. The body of the function isnâ€™t run until itâ€™s called from somewhere else in the code. And at that time execution will jump to the beginning line of the function body. ğŸ¤–Define a function: Hey, there exists a function called Ã—Ã—Ã—Ã—. Just keep that in mind for now. ğŸ¤–Call a function: Hey, remember the function that I told you about earlier? Go ahead and run it now. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:4:1","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Scope of a Function The scope of a function is from the line where itâ€™s defined to the end of the code. If we tried to call it before it was defined, itâ€™s out of scope and weâ€™d receive an error because it hasnâ€™t yet been defined. This is a little bit different from compiled languages. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:4:2","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Common Function Errors The two common errors weâ€™ll encounter with functions are: Parameter Mismatch: We gave a function more or fewer parameters than it expected. Scope Error: We tried to use a variable in a function that was created outside the function, or similarly, we tried to use a variable outside a function that was created inside the function. The scope of any variable created inside a function ends when the function ends. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:4:3","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Functions Returning None When a function runs a line with a return statement, it immediately ends the function and sends the result back. But if a function does not otherwise return anything, it returns None. You can imagine adding return None as the last line in any function. If no other return statement has already been run, then return None is run and None is returned. Remember, though, running a return statement terminates the function: as soon as one runs, the entire function ends no matter what. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:4:4","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Positional \u0026 Keyword Parameters Positional parameters/required parameters are called â€œpositionalâ€ specifically because Python assumes the match-up between argument and parameter based on position. Keyword parameter/named parameter/optional parameter is a special kind of optional parameter to which the program may choose to assign an argument during a function call, or may ignore. Typically, keyword parameters have a default value that is used if it is not overridden by a function call. For positional parameters, Python assumes that arguments come in the order that parameters are defined in a function definition. For keyword parameters, we have to use the variable names, because Python canâ€™t assume anything based on the order of these parameters. Keyword (optional) parameters must go after all positional (required) parameters. But the order of the keyward parameters themselves is not important. def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2): where / and * are optional. If used, these symbols indicate the kind of parameter by how the arguments may be passed to the function: parameters before the / are positional-only; parameters between / and * are positional-or-keyword; parameters after the * are keyword-only. *name receives a tuple containing some positional arguments; **name receives a dictionary containing some keyword arguments. \u003e Eg., if we define a function like this: def cheeseshop(kind, *arguments, **keywords): print(\"-- Do you have any\", kind, \"?\") print(\"-- I'm sorry, we're all out of\", kind) for arg in arguments: print(arg) print(\"-\" * 40) for kw in keywords: print(kw, \":\", keywords[kw]) It could be called like this: cheeseshop(\"Limburger\", \"It's very runny, sir.\", \"It's really very, VERY runny, sir.\", shopkeeper=\"Michael Palin\", client=\"John Cleese\", sketch=\"Cheese Shop Sketch\") and of course it would print: -- Do you have any Limburger ? -- I'm sorry, we're all out of Limburger It's very runny, sir. It's really very, VERY runny, sir. ---------------------------------------- shopkeeper : Michael Palin client : John Cleese sketch : Cheese Shop Sketch Note that the order in which the keyword arguments are printed is guaranteed to match the order in which they were provided in the function call. Besides, in a function call, lists or tuples can deliver positinal arguments with the *-operator; and dictionaries can deliver keyword arguments with the **-operator: \u003e\u003e\u003e args = [3, 6] \u003e\u003e\u003e list(range(*args)) # call with arguments unpacked from a list [3, 4, 5] \u003e\u003e\u003edef parrot(voltage, state='a stiff', action='voom'): ... print(\"-- This parrot wouldn't\", action, end=' ') ... print(\"if you put\", voltage, \"volts through it.\", end=' ') ... print(\"E's\", state, \"!\") ... \u003e\u003e\u003ed = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"} \u003e\u003e\u003eparrot(**d) # call with arguments unpacked from a dictionary -- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised ! ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:4:5","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Extra Materials ğŸPythonâ€™s official documentation on functions ğŸHands-on Python Tutorial ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:4:6","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Chapter 3.5: Error Handling Catching Errors:Â Using error handling to prevent a program from crashing when an error is encountered. Uncaught Error:Â An error that is not handled by error handling code, and thus usually forces the program to crash. Sometimes, instead of preventing errors, we want to use the fact that an error arose to direct or control our program. The actual structure of error handling is itself a control structure. The three main structures for exception handling in most languages are theÂ try,Â catch, andÂ finallyÂ statements: TheÂ TryÂ statement marks a block of code to attempt, but in which we anticipate an error might arise. Error handling is kind of like a conditional statement. We could handle errors with a conditional by saying, if an error is going to arise, donâ€™t run this code. Else, do run it. In that structure, we would put the code that we actually want to run in the else portion of the structure. The try block is thus similar to the else block. Itâ€™s a block of code marked off to run if some other code didnâ€™t take place. However, the try block is slightly different in that it will always try to run, and stop only when an error is encountered. TheÂ CatchÂ statement names the errors to anticipate, and marks a block of code to run if an anticipated error arises. (Python often refers to this as theÂ ExceptÂ block as well.) When a try block didnâ€™t succeed, and encountered an error, the computer jumps forward to the catch block (except: in Python). It contains the code the computer should run if an expected error was encountered. The catch block also has one additional detail declared with itâ€“ the type of error to be expected. We can tell the computer exactly what kind of error to catch. In some languages, we can even skip the catch block altogether. A try without a catch just tells the computer not to crash if the code inside the try block raises any kind of error. TheÂ FinallyÂ statement marks a block of code to run after the above two blocks no matter what. The finally block contains code that should be executed after the code in the try block whether it succeeded or not. If the code in the try block ran without errors, then execution will jump to the finally block when the try block is done. If the code in the try block did hit an error execution, will in most languages, run what is in the catch block next and then will always run the code in the finally block. The finally block is typically used for code that absolutely needs to run, even if other things have gone wrong. ğŸPython is not a language that allows a try without catching something, So we need to include both the try and the catch. ğŸIn Python, there is also anÂ ElseÂ block for exception handling: it runs some code only if no errors arose in the Try block. Most languages have a Finally statement, but Else (at least as it applies to error handling) is relatively unique to Python. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:5:0","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Error Catcher: try-except blocks Three kinds of errors are specifically generated: my_int = int(my_string): This line generates a ValueError ifÂ my_stringÂ does not hold a string that can be read as an integer. For example, ifÂ my_stringÂ wasÂ â€œ5â€ or â€œ1885â€, no error would arise; ifÂ my_stringÂ was â€œTaco.â€ or â€œBoggle.â€, an error would arise. print(\"String #\" + 1 + \": \" + my_string): This line generates a TypeError because we cannot use the + operator to put together strings (likeÂ â€œString #\") and integers (likeÂ 1). print(1 / 0): This line generates a ZeroDivisionError error because we cannot divide by zero. myString = \"This string is not a number!\" try: print(\"Converting myString to int...\") # ValueError print(\"String #\" + 1 + \": \" + myString) # TypeError print(1/0) # ZeroDivisionError myInt = int(myString) print(myInt) except pass print(\"Done!\") The try block attempts to run the code inside of it, but if it fails, the try block tells the execution to jump to the catch (except) block. The code would then execute whatever is inside that except block. Then, once these two control structuresâ€“ this try and this exceptâ€“ are done, execution continues as normal. Every Try block in Python must have a corresponding Except block (catch block). In terms of natural language, we can think of this as saying try to do this except if something goes wrong, in which case, do this. Or in other words, try this except if this error happens. The keyword as in Python basically takes whatever the error was and assigns the message associated with that specific error to the variable name after the keyword as. except ValueError as error_message: print(error_message) Notice that no matter how many errors occur in the try block, as soon as the code encounters the first, it jumps over the rest of the try block and starts to check the except blocks. Three kinds of except block could be used to handle specific errors: Catch a specific error \u0026 customized message except ValueError as error: # if a ValueError was encountered print(\"Can't convert; myString is not a number\") Catch a specific error \u0026 pre-determined message except block is similar to if block except ValueError as error: # if a ValueError was encountered print(error) except TypeError as error: # if a TypeError was encountered print(error) print(\"Done!\") Catch multiple specific errors except (TypeEror, ValueError) as error: print(\"A ValueError or TypeError occurred.\") except Exception as error: # Catch any type of error print(\"Some other type of error occurred.\") print(\"Done!\") The except block with parentheses will run if any of the errors given in that parentheses were encountered. Since the error type Exception catches any kind of error, this code will never crash. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:5:1","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Else Block To use an else with error handling, we add it after the except blocks. The else block basically says, if no error was encountered, then run the code inside this block. ğŸ¤”â€”Why we need an else block? Why not just include this code down here after the try and catch blocks? ğŸ¤–â€”Style is everything! In many languages, itâ€™s normal to have huge blocks of code inside of a try block, even though the expected errors might only occur in one or two places. The else block lets us restrict this try block to only those lines of code that might actually generate an error. The else block will only run, if no errors were encountered. So we can trust that everything inside the try block happened successfully before running the things inside that else block. Example: File Input This code below opens a file and then prints every line of text that was found inside that file. And then at the end, it closes the file again. Here, weâ€™re trying to catch an IOError, an input/output error, inside this try block. It only happens when the code tries to read from a file that does not exist (eg., in function open()). try: input_file = open(\"InputFile.txt\", mode = \"r\") except IOError as error: print(\"An input error occurred!\") else: for line in input_file: print(line) input_file.close() open(filename): Takes as input a filename and returns the file. Once returned, the file can be read line-by-line or written to, depending on the mode. Mode is set with the keyword parameter â€œmodeâ€, â€œrâ€ for read, â€œwâ€ for write, â€œaâ€ for append. filename.close(): A method that closes the file of which itâ€™s a member. Some languages actually require file input and output to be enclosed in try/catch blocks because of how frequently they generate errors. Python, however, has a more laissez-faire attitude and will let us mess up if we want to. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:5:2","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Finally Block If an error is caught, there is no difference whether a command is inside a finally block or outside of the try-except-else blocks. However, once thereâ€™s a finally block, the code inside the finally block will still run, even if the type of error was not caught. The code would still crash anyway if an uncaught error arose, but we can get some output first. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:5:3","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Nested Try-Catch-Else-Finally For-loop inside try block: any error would terminate the process. try: input_file = open(\"InputFile.txt\", mode = \"r\") except IOError as error: print(\"An error occurred reading the file!\") else: try: for line in input_file: print(int(line)) except ValueError as error: print(\"A value error occurred!\") else: print(\"No errors occurred converting the file!\") finally: input_file.close() Try block inside for-loop: when an error occurs, the code skips the current iteration and jumps to the next one, so the file reading process continues. try: input_file = open(\"NumberAndLetterFile.txt\", mode = \"r\") try: for line in input_file: print(int(line)) except ValueError as error: print(\"A value error occurred!\") else: print(\"No errors occurred converting the file!\") finally: input_file.close() except IOError as error: print(\"An error occurred reading the file!\") ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:5:4","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Extra Materials The officialÂ Python error documentation The Python Wikiâ€™sÂ guide to handling exceptions ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:5:5","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Appendix 1. Python Translation Guide table th:first-of-type { width: 10%; } table th:nth-of-type(2) { width: 45%; } table th:nth-of-type(3) { width: 45%; } ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:6:0","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Indicating Control Structures Python is actually considered somewhat odd in its formal use of indentation to indicate control structures. Most languages are indented by convention, but have more formal mechanisms to indicate the scope of a control structure. Most languages use brackets { } to indicate the scope of a control structure. The lines inside the control structure are typically indented for readability, but it would be possible to remove all indentation and still have working code in these languages. Language Syntax Notes Python if True: #Some code would go here! #The control structure is over when the indentation ends. Java, C, C++, C#, JavaScript, Swift if (true) { /* An open bracket starts the control structure. */ /* Some code would go here! */ } /* A close bracket ends the control structure. */ You will findÂ vicious argumentsÂ online over whether the open bracket should go alongside the control structure or on the next line. Personally, I prefer the same-line structure. VB.NET If True Then â€˜Some code would go here! End If â€˜The VB.NET keyword End If ends the control structure VB.NET does not require an additional character or keyword to start a control structure, but does require one to end a structure. It infers the control structure starts when it sees a control structure keyword likeÂ If, and then it formally declares the control structure over with something likeÂ End If. Matlab if true %Some code would go here! end %The keyword end ends the control structure. Like VB.NET, Matlab has a formal keyword reserved for ending control structures:Â end. Ruby if true #Some code would go here! end #The keyword end ends the control structure. Like VB.NET, Ruby has a formal keyword reserved for ending control structures:Â end. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:6:1","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"If, Else If, and Else Every major language offers the basic functionality of an if, else-if, and else. Some languages even offer a single operator that lets you do these all on one line, called a ternary operator, but weâ€™ll focus on the more general structure. Language Syntax Notes Python if some_bool: #Some code would go here! elif some_other_bool: #Some other code would go here! else: #Some other code would go here! Java, C, C++, C#, JavaScript if (some_bool) { /* Some code would go here! */ } else if (some_other_bool) { /* Some other code would go here! */ } else { /* Some other code would go here! */ } Youâ€™ll also find lots of arguments online about whether the closing bracket should go on the same line as the else if and the else. I prefer to keep the brackets on the same line; we can always add extra blank lines if we want to for readability. Note that in these languages, the condition itself must go inside parentheses. VB.NET If some_bool Then â€˜Some code would go here! ElseIf some_other_bool Then â€˜Some other code would go here! Else â€˜Some other code would go here! End If VB.NET capitalizes its conditional keywords (If,Â ElseIf,Â Else, andÂ End If), and it also has an optional keywordÂ ThenÂ that makes the code read a little more like natural language. It reads quite nicely if we use boolean names likeÂ today_is_monday. It also ends a conditional with the dedicated keywordÂ End IfÂ instead of a close bracket. Matlab if some_bool %Some code would go here! elseif some_other_bool %Some other code would go here! else %Some other code would go here! end Like VB.NET, Matlab has a dedicated keyword to end a conditional structure:Â end. Swift if some_bool { /* Some code would go here! */ } else if some_other_bool { /* Some other code would go here! */ } else { /* Some other code would go here! */ } Swift is identical to Java and C except that it does not require parentheses around the conditional expression. Ruby if some_bool #Some code would go here! elseif some_other_bool #Some other code would go here! else #Some other code would go here! end Ruby is identical to Matlab, which is weird. ","date":"2021-10-25","objectID":"/gatech-cs1301xii/:6:2","tags":null,"title":"Gatech CS1301xII","uri":"/gatech-cs1301xii/"},{"categories":null,"content":"Intro to Computing in Python by David Joyner","date":"2021-10-21","objectID":"/gatech-cs1301xi/","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":" Extra materials How to Think Like a Computer Scientist: Interactive Edition How to Think Like a Computer Scientist: Learning with Python 3 Python for Everybody (PY4E) Hands-on Python 3 Tutorial Beginning Python Programming for Aspiring Web Developers Course Outline ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:0:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Unit 1 Computing:Â the basic principles of working with computers. Programming:Â the general workflow of writing and running programs. Writing code, compiling it, executing it, and evaluating the results. Debugging:Â the process of finding and fixing errors in your programs. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:1:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Unit 2 Procedural Programming: The general idea of writing sequences of instructions for the computer to perform. Variables: Creating and modifying data in our programs. Logical Operators: Establishing the truth or falsehood of relationships among variables in our programs. Mathematical Operators: Using arithmetic operators (addition, multiplication, etc.) to modify the values of variables in our programs. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:2:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Unit 3 Control Structures: The general idea of lines of code that can control other lines of code. Conditionals: Lines of code (called if statements) that check logical expressions to see if certain code blocks should run. Loops: Lines of code that instruct the computer to repeat a block of code until some condition is met. Functions: Miniature programs within a larger program, each with their own input, code, and output. Exception Handling: Lines of code that instruct the computer how to fail gracefully when errors are encountered. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:3:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Unit 4 Data Structures: The general idea of data types more complex than individual letters and numbers. Strings: Ordered series of characters that often represent natural human language. Lists: Ordered series of other kinds of data, collected under one variable name and accessed via numeric indices. File Input/Output: Writing a programâ€™s data to a file so it can later be re-loaded after the program is closed and reopened. Dictionaries: Pairs of keys and values collected under one variable name, like lists with non-numeric indices. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:4:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Unit 5 Objects: Creating and using custom data types so our programs can reason about the world the way we do. Algorithms: Complex sequences of instructions that transform data or generate useful conclusions. Unit 1 ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:5:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Chapter 1.1: Computing ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:6:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Programming Vocabulary Code: Commands given to a computer in order to perform a task. Line of code: A single command. Program: A collection of lines of code that serve one or more overall functions. Input (files, user input, websites) ğŸ‘‰ code ğŸ‘‰ output (files, screen, sound) Compile: To translate human-readable computer code into low-level commands the computer can execute. In the programming flow, this functions as reading over code and looking for errors. (proofreading by compilers) Run/Execution: Running some code and having it actually perform its operations. Compiling just makes sure what we told the program to do makes sense; running checks whether the program actually do what we want it to do. Compilation could potentially be skipped. Languages that require compilation are called static/compiled languages. Languages that do not require compilation are called dynamic/interpreted languages. Two kinds of programs process high-level languages into low-level languages: interpreters and compilers. An interpreter reads a high-level program and executes it. It processes the program a little at a time, alternately reading lines and performing computations. A compiler reads the program and translates it completely before the program starts running. In this case, the high-level program is called the source code, and the translated program is called the object code or the executable. Once a program is compiled, you can execute it repeatedly without further translation. Many modern languages use both processes. They are first compiled into a lower level language, called byte code, and then interpreted by a program called a virtual machine. Python uses both processes, but because of the way programmers interact with it, it is usually considered an interpreted language. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:6:1","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Programming Language Categorization of languages: Static \u0026 Dynamic: whether compilation is required Hight-level languages involve a great deal of abstraction from the low-level details of the computer like memory, whereas low-level languages such as machine languages or assembly languages require these details to be addressed manually. Popularity of different languages C++ and C# are two successors to the programming language C, which is a low-level language used a lot in developing operating systems, video games, and other highly complex programs. C++ adds a few more features to C, while C# is more of a high-level version. Java, C, C++, and C# are static, compiled languages; Python is the top dynamic, scripting language on this list. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:6:2","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Console vs. GUI Graphical user interfaces (GUIs): An output medium that uses more than just text, like forms, buttons, tabs, and more. Eg. a web browser, a word processor like Microsoft Word, a smartphone app, a modern operating system like Windows or Mac OS. Console: An output medium for a program to show exclusively text-based output. Eg. command line interfaces like the terminal on a Mac or the command window on a PC. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:6:3","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Fundations, language, and domain Foundations are the core principles of computing that transcend specific programming languages. These foundational principles are then implemented in specific programming languages. You then apply them to a particular domain. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:6:4","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Python Python is a high-level, platform-independent programming language. Python abstracts further away from the inner workings of the computer than lower-level languages (like memory management), thus is easier to use. Python is dynamic \u0026 interpreted, which means that Python will run our code line by line when we ask it to without trying to compile it first. That opens up the possibility of using Python in a command line interface where we write and run lines of code one at a time. Whereas in the scripting mode, we write a bunch of code, then run it all at once. The main takeaway of Python being an interpreted language is that we might not be aware of errors until we actually try to run those lines. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:6:5","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Extra materials How to Think Like a Computer Scientist: Interactive Edition How to Think Like a Computer Scientist: Learning with Python 3 ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:6:6","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Chapter 1.2: Programing Programming is an iterative process of writing code, attempting to run it, and evaluating the results (writeâ‡¨runâ‡¨evaluate cycle). Interchangeable with coding. Work in Small Chunks Chaining Together Instructions Debugging to address errors, incorrect results ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:7:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Chapter 1.3: Debugging Debugging:Â Resolving problems in code, whether it be errors thrown in compilation or running or mismatches between the desired and observed output. The terms â€œbugâ€ and â€œdebuggingâ€ are popularly attributed to Admiral Grace Hopper in the 1940s. While she was working on a Mark II Computer at Harvard University, her associates discovered a moth stuck in a relay and thereby impeding operation, whereupon she remarked that they were â€œdebuggingâ€ the system. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:8:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Types of errors Compilation Errors: Errors that occur during the computerâ€™s read through of the code. Compilation errors in writing programs are often similar to grammatical errors in writing essays. syntax errors: code that doesnâ€™t work with the current programming language. name errors: code that tries to use something that doesnâ€™t exist. type errors: code that matches different types together, which doesnâ€™t make sense. Depending on the language, some of these might turn up as runtime errors instead. Runtime errors: Errors that arise when trying to actually execute the code. Languages that donâ€™t have compilation will only have runtime errors. Even languages that do require compilation can have runtime errors because we canâ€™t anticipate every error just by looking at the code. Divide by zero errors: code that divides a value by zero. Null errors: code that refers to some variable that has no value. Memory errors: code that surpasses your computerâ€™s memory. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:8:1","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Types of errors in Python NameError An error usually occurs when you use a variable name that doesnâ€™t yet exist. When you encounter these, check first for misspellings; you very likely might have misspelled a variable name, causing the computer to see it as a completely different variable! If that doesnâ€™t work, try to find where you first defined the variable. TypeError An error occurs when we try to perform an operation on an object that doesnâ€™t make sense with the operation, like calculating the length of a number or printing an omelet. The function cannot deal with the object. AttributeError An error occurs when we ask for informationÂ aboutÂ a variable that doesnâ€™t make sense, like the happiness of a potato or the GPA of a turnip. The object does not have the attribute. SyntaxError An error occurs when the line of code weâ€™ve written canâ€™t be read by the computer because it doesnâ€™t match the computerâ€™s expectation for the programming languageâ€™s grammar. Usually, unclosed parentheses will cause a SyntaxError on the next line of code. But depending on your code, unclosed parentheses can actually manifest as other kinds of errors. For example, if it was actually theÂ lastÂ line that had a missing close-parentheses, you would still get a syntax error, but it would read â€œunexpected EOF while parsingâ€. EOF stands for â€œend of fileâ€ and â€œparsingâ€ is a fancy word for â€œreadingâ€, so â€œunexpected EOF while parsingâ€ means that Python encountered the end of the file before it expected to. So, when you get an error on a line that looks okay, learn to quickly check for unclosed parentheses on the line of code before. Others Check the debugging guide. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:8:2","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Basic debugging Print Debugging: A form of debugging where print statements are added throughout the code to check how the program is flowing. Scope Debugging: A form of debugging where print statements are added to check the status of the variables in the program at differentÂ stages to see how they are changing. (Debugging small sections/scopes of a program to make sure things have run correctly so far.) Rubber Duck Debugging: A form of debugging where the programmer explains the logic, goals, and operations to an inanimate listener to methodically step through the code. The point is when faced with a hard-to-solve problem, try explaining it from scratch. Oftentimes, youâ€™ll find the solution. Rubber duck debugging was introduced by the 1999 book The Pragmatic Programmer, and it refers to a programmer who carried around a rubber duck to which to explain problems. By explaining things to the duck, the programmer often found the solution. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:8:3","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Advanced debugging Step by step execution: run your code one line at a time. Variable visualization: you can view the status of every variable at any time. In-line debugging: while youâ€™re writing code, itâ€™ll show you right there if youâ€™ve done something wrong; visualized very similarly to spell check. Itâ€™s almost as if the computer is constantly compiling your code, just to make sure it works, while youâ€™re writing it. Unit 2 ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:8:4","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Chapter 2.1: Procedural Programming ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:9:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Function and Method Function: A segment of code that performs a specific task, sometimes taking some input and sometimes returning some output. Method:Â A function that is part of a class in object-oriented programming (but colloquially, often used interchangeably with function). ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:9:1","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Programming paradigms Procedural Programming: where procedural code is the one that directly instructs a device on how to finish a task in logical steps. Object-Oriented Programming:Â A programming paradigm where programmers define custom data types that have custom methods embedded within them. A concept or an abstraction is created before executing some other commands. Event-Driven Programming:Â A type of programming where the program generally awaits and reacts to events rather than running code linearly. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:9:2","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Operators Operators: Specific, simple functions that act on primitive data types, like integers and strings. Mathematical Operators:Â Operators that perform mathematical functions, like adding numbers together or assigning values to variables. (+ - * / % **) Logical Operators: Operators that perform logical operations, such as comparing relative values, checking equality, checking set membership, or evaluating combinations of other logical operators. Typically, operators work on the most primitive types in programming languages: mathematical operators work on integers and floats, while logical operators work on booleans. Some languages, though, allow us to use operators in creative ways. In Python, we can use the mathematical plus (+) operator to concatenate strings (put two strings together), and the multiplication (*) operator to multiply a string by an integer to duplicate it. We can also use subtraction with dates to find the time between different dates. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:9:3","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Comments and Documentation Comments: Notes from the programmer supplied in-line alongside the code itself, designated in a way that prevents the computer from reading or attempting to execute them as code. [in-line comments (pound/hash mark #) \u0026 block comments] There exist ways of writing comments that can be pulled out to generate separate, standalone documentation. Documentation: Collected and set-aside descriptions and instructions for a body of code. Self-Documenting Code: Code whose variables and functions are named in a way that makes it clear what their underlying content and operations clear to the reader. Supplemental material ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:9:4","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Chapter 2.2: Variables ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:10:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Basic concepts Variables: Alphanumeric (letters and numbers) identifiers that hold values, like integers, strings of characters, and dates. Value:Â The content of some variable. The variableÂ my_ageÂ might hold the value 21. The variableÂ your_nameÂ might hold the value â€œGreymaneâ€. Null: The â€œvalueâ€ a variable has when it doesnâ€™t actually have a value. Naming rules: Variables (as well as functions, methods, classes, and other stuff weâ€™ll learn about later) cannot have spaces in them. Variable names can ==only contain letters, numbers, and underscores==. Variable names must ==start with letters==. Technically underscores are also allowed, but we generally only use those in certain situations. Variable names must not duplicate certain ==reserved words==. Names are case sensitive. A good name is ==self-documenting==. See more on this website. Two common conventions are used if the name has more than one word: camel case and underscores. Each programming language has its own accepted style. **In Python,Â you should use underscores. In Java and C#, you would use camel case**. Other languages have their own conventions. Camel caseÂ mushes the words together and capitalizes each word, like this:Â thisIsMyVariableName. Note that the first letter of a variableâ€™s name is usually in lowercase, while the first letter of a functionâ€™s name is often in uppercase. UnderscoresÂ just replaces spaces with underscores, usually keeping the variable name in all-lowercase, like:Â this_is_my_variable_name. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:10:1","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Data types Integer, real number, character, string, booleanâ€¦self-defined typesâ€¦ See more on this website. In strongly-typed languages, assigning a type to a variable is actually a separate step from assigning a value to the variable; and assigning a different type to this variable will cause crashing. We can multiply a sequence (string, listâ€¦) by an integer, and Python just takes that sequence and repeats it however many times we multiplied it by. But we canâ€™t multiply a sequence by a float or a string by a string. Also, when Python is asked to use a boolean like a number (such as multiplying by a boolean), it interprets True as 1 and False as 0. Now, letâ€™s meet a weird guy in Pythonâ€”the NoneTypeâ€”which only has one value: None. None is Pythonâ€™s implementation of the programming concept of ==null== (like the null pointer in C++). This is how Python represents that a variable has no value. This is slightly different from a variable simply not existing: ==the variable name exists, it just doesnâ€™t point to any value==. Because there is no value, it also doesnâ€™t fit into any of the above types. Where Does None Come From? First, the trivial way, we could just do that intentionally. The way it will happen more commonly is that youâ€™ll set it equal to some operation that doesnâ€™t result in anything, like you put on the right of an equal sign a function that has no return value (eg. the print() function) ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:10:2","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Type conversion To treat a certain type of data with operations, functions, or methods of a different data type, we have to use functions for converting between the two. Implicit conversion: In practice, you may not always need to do this manually, though. For example, when you put a value other than a string into Pythonâ€™s print function, it automatically tries to convert it to a string. When we use comma instead of plus sign, it tells the print statement to interpret each individual thing in the parentheses as a separate piece of data. The print statement ==implicitly converts each thing to a string if needed and then puts them together==. By default, it puts each thing together separated by a space. Youâ€™ll receive a ==ValueError== whenever you try to do a type conversion, like float or integer, on a value that canâ€™t actually be converted to that type. ==int(variable)==: Takes as input some variable (usually a string) and attempts to convert it to an integer, returning the integer if successful or raising aÂ ValueErrorÂ if unsuccessful. This function will work ifÂ the variableÂ is a string made up only of digits and, optionally, the negative sign. Note that conversion from float to int by int() just wiping out the decimal part. If you want to convert float to int type value in Python with a round figure. You have toÂ use theÂ round()Â functionÂ of Python inside theÂ int()Â function. ==bool(variable)==: Takes as input some variable (usually a string) and attempts to convert it to a boolean, returning the boolean value if successful or raising aÂ ValueErrorÂ if unsuccessful. Generally, this function returns False ifÂ the variableÂ is 0 or an empty string, True ifÂ the variableÂ is anything else. ==float(variable)==: Takes as input some variable (usually a string/integer) and attempts to convert it to a float, returning the float if successful or raising aÂ ValueErrorÂ if unsuccessful. This function will work ifÂ the variableÂ is a string made up only of digits and, optionally, a negative sign and a decimal point. The computer interprets anything that the user enters by the ==input(variable)== function as a string of characters because it has no way of knowing that itâ€™s a number. So, type conversion is needed under certain circumstances. Usually, int(input(variable)) is used if we want to use the user input as a number. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:10:3","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Reserved keywords in Python import keyword print(keyword.kwlist) Importing Libraries.Â ==import,Â from==. Logical Operators.Â ==and,Â is,Â not,Â or,Â False,Â True,Â None==. Control Structures.Â ==as,Â break,Â continue,Â if,Â elif,Â else,Â for,Â in,Â while,Â pass,Â with==. Functions.Â ==def,Â return==. Object-Oriented Programming Syntax.Â ==class==. Error Handling.Â ==except,Â finally,Â raise,Â try==. The remaining words: ==assert, del, global, lambda, non-local, yield== are outside of the scope of the course. If a reserved word is used as a variable name or a function name, a SyntaxError will be triggered. But if a function name in Python like print is used for a new variable name, assigning value to this variable will not cause any problem, but weâ€™ve hidden the fact that it can also be used as a function. It can only mean one thing for a given block of code, and weâ€™re changing its meaning. When we try to use the word as a function name, a TypeError will arise. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:10:4","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Chapter 2.3: Logical Operators ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:11:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Relational Operators Check the relationships between multiple variables. Numeric Comparison Operators Operators that facilitate numeric comparison between values. Typically, these are â€˜greater thanâ€™ (\u003e), â€˜greater than or equal toâ€™ (\u003e=), â€˜equal toâ€™ (==), â€˜less thanâ€™ (\u003c), and â€˜less than or equal toâ€™ (\u003c=). These operators can sometimes be used for comparisons that are not numeric, but that nonetheless have an underlying order: A string of characters is â€˜lessâ€™ than another string if it comes earlier alphabetically. â€œAppleâ€ would be less than â€œBananaâ€. â€œZâ€ would be less than â€œaâ€. â€œ12â€ would be less than â€œ3â€. â€œQuickâ€ \u003c â€œQuickerâ€, â€œQuickerâ€ \u003c â€œQuicklyâ€ A date is â€˜lessâ€™ than another date if it comes earlier in time. January 1st, 2017 would be â€˜lessâ€™ than January 15th, 2017. Itâ€™s also worth noting that the greater than and less than operators do work for strings as well, and they operate based on sorting the strings alphabetically. Besides, in Python, all capital letters are sorted before all lowercase letters, so a string beginning with a capital Z would be treated as less than a string beginning with a lowercase a. Non-Numeric Equality Comparisons Nearly any kind of data can compare for equality, even if it isnâ€™t numeric. We canâ€™t ask if an apple is greater than an orange, but we can ask if apples and oranges are â€˜equalâ€™, or the same thing. In practice, sometimes this will compare values to see if the values of two variables are the same, and other times it will compare if two variables are pointing to the same data in memory. It could be that two variables have the same values, but those values are stored in separate places, and so the computer doesnâ€™t recognize them as equal. Set Operators Check to see if a value is a member of a set of multiple values. Most often this comes up in strings and lists. With strings, we can check to see if a certain smaller string occurs inside a larger string. For example, â€œcdeâ€ is in the string â€œabcdefgâ€, but â€œijkâ€ is not. With lists, we can check to see if a certain item is on our list. For example, if we had a list containing â€œgrapesâ€, â€œapplesâ€, and â€œorangesâ€, then â€œapplesâ€ would be in that set, but â€œpapayaâ€ would not. Relational Operators in Python In many of these examples, weâ€™ll have a logical expression, and weâ€™ll set the result of it equal to a variable. Then, we can check the variable to see what the result of the expression was. We may also print the results of a logical expression directly. Note that a single equal sign (=) is for assignment, while a double equal sign (==) is for comparison. The ==in== operator checks to see if something is contained within a list of other things. For one example, we can use the in operator in the context of strings to see if a certain smaller string is contained within a larger string. Note, the empty string ==\"\"== is in all the strings. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:11:1","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Boolean Operators Operators like â€œandâ€ and â€œorâ€ that act on pairs of boolean (true or false) values, or that act on single boolean values, like â€œnotâ€. They check the combination of multiple relational operators. ==And==:Â An operator that acts on two boolean (true or false) values and evaluates to â€œtrueâ€ if and only if both are true. ==Or==: An operator that acts on two boolean (true or false) values and evaluates to â€œtrueâ€ if and only if at least one is true. ==Not==:Â An operator that acts on one boolean (true or false) value and evaluates to the opposite value (false becomes true, true becomes false). Priority sequence: parentheses \u003e mathematical operators \u003e not \u003e and \u003e or Refer to Operator precedence ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:11:2","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Truth Tables Tables that map out the results of a statement in boolean logic (that is, using boolean operators) depending on the values of the individual variables. Properties of Boolean Operators: First, Boolean operators are commutative. What that means is it doesnâ€™t matter what order they come in. ==A and B=B and A== Logical expressions or logical operators are also distributive. ==A and (B or C)=(A and B) or (A and C)== ==De Morganâ€™s Law #03A9F4==: ==not (A and B)=not A or not B==; ==not (A or B)=not A and not B==. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:11:3","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Extra materials Python Boolean Logic: Not As Scary As It Sounds ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:11:4","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Chapter 2.4: Mathematical Operators ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:12:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Basics Operators that mimic basic mathematical functions: Addition + Subtraction - Multiplication * Division / Modulus % Assignment Operator = Note that in Python, division in Python will automatically convert integers into a float/decimal number. The reason for that is that whenever we do addition, subtraction, or multiplication on integers, weâ€™re guaranteed to end up with an integer. However when we do division, we might end up with a decimal number. And itâ€™s probably worth noting that this actually sets Python apart from other languages as well. Some other languages will automatically round down when you round integers. But if there is a float anywhere in a mathematical expression, Python automatically converts the other type to a float, and the result will also be a float. Eg. the result of 1.5//2 is 0.0. Besides, the Modulus Operation will only return the remainder having the same sign as the divisor. Eg. the result of -8%3 is 1, the result of 8%-3 is -1, and the result of -8%-3 is -2. Python specifically supplies two additional operators: Floor division, represented by a double-slash (\\\\), which is division that rounds down to the next lowest integer (not round towards 0). For example, 5 // 2 would be 2, because 5 divided by 2 is 2.5, which is rounded down to the nearest integer, 2. Exponentiation, represented by a double-asterisk (**), which raises the first number to the second number. For example, 5 ** 2 would be 25, because 5 raised to the 2nd power is 25. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:12:1","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Self-Assignment and Incrementing Self-AssignmentÂ means assigning a variable to a value that is in part determined by the variable itself. Increment:Â Repeatedly adding a constant, typically one, to a variable. Self-assignment reveals something very important about the assignment operator: Python (and most other programming languages) will evaluate everything on the right side of the assignment before attempting to assign the result to the variable on the left. Thatâ€™s why self-assignment works: Python initially replaces the variables with their values, so by the time we assign a new value to a variable, Python doesnâ€™t remember that the variable receiving a new value was used in the calculation. Self-Assignment Shortcuts: +=, -=, *=, **=, /=, //=, %= Sometimes these shortcuts even work for those strange non-mathematical applications of these mathematical operators. For example, we can use the shortcut += to add something to an existing string. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:12:2","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Extra materials Python Operators are Mathematical! ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:12:3","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Appendix 1. Python Translation Guide ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:13:0","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Print Statements and Line-Ending Behaviors table th:first-of-type { width: 10%; } table th:nth-of-type(2) { width: 40%; } table th:nth-of-type(3) { width: 50%; } Language Syntax Notes Python print(â€œHereâ€™s a line of codeâ€) print(â€œHereâ€™s another one!\") By default,Â print()Â adds a line break to the end of the printed text. Java System.out.println(â€œHereâ€™s a line of codeâ€); System.out.println(â€œHereâ€™s another one!\"); Like Pythonâ€™sÂ print(), Javaâ€™sÂ System.out.println()Â adds a line break after the printed text.Â In contrast, System.out.print()Â will print some text without creating a new line afterward. C printf(â€œHereâ€™s a line of codeâ€); printf(â€œHereâ€™s another one!\"); In C, theÂ printf()Â function does not add a line break after the printed text. To do that, you need to include â€œ\\nâ€ inside the printed text itself, e.g.Â printf(â€œNew line please!\\nâ€). C++ std::cout Â« â€œHereâ€™s a line of codeâ€; std::cout Â« â€œHereâ€™s another one!\"; Like C, C++â€˜sÂ coutÂ will not add a new line after the printed text. To add one, we would need to writeÂ std:cout Â« â€œNew Line please!\\nâ€. C# Console.WriteLine(â€œHereâ€™s a line of codeâ€); Console.WriteLine(â€œHereâ€™s another one!\"); C#â€™s Console.WriteLine() function add a line break after the printed text. Like Java, C# also has aÂ Console.Write()Â function that will write without starting a new line afterward. JavaScript console.log(â€œHereâ€™s a line of codeâ€) console.log(â€œHereâ€™s another one!\") By default,Â console.log()Â adds a line break to the end of the printed text. VB.NET Console.WriteLine(â€œHereâ€™s a line of codeâ€) Console.WriteLine(â€œHereâ€™s another one!\") C# and VB.NET use the same underlying library, so youâ€™ll find that oftentimes syntax likeÂ Console.WriteLineÂ is shared between them. Matlab fprintf(â€œHereâ€™s a line of code); fprintf(â€œHereâ€™s another one!\"); Like C, Matlabâ€™sÂ fprintfÂ will not add a new line after the printed text. To add one, we would need to writeÂ fprintf(â€œNew Line please!\\nâ€). Swift print(â€œHereâ€™s a line of codeâ€) print(â€œHereâ€™s another one!\") By default,Â print()Â adds a line break to the end of the printed text. Ruby puts â€œHereâ€™s a line of codeâ€ puts â€œHereâ€™s another one!â€ By default,Â putsÂ adds a line break to the end of the printed text. Scripting languages (Python, JavaScript) generally do not use a semi-colon to mark the ends of lines. Most compiled languages (Java, C, C++, C#) use semi-colons. There are exceptions, though; Swift and VB.NET are compiled languages that do not use semi-colons, while MatLab is a scripting language that does. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:13:1","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Comment Syntax Pythonâ€™s comment syntax is in the minority. Language Syntax Notes Python #This is a comment in Python #This is a #multiline comment #in Python Triple quotes can also be used in Python to create multi-line comments. Java //This is a comment in Java /* * This is a * multi-line comment * in Java */ The asterisks at the beginning of each line inside the multi-line comment are customary, but not required. Java, C++, JavaScript, and C# use the same syntax. C /* This is a comment in C*/ /* This is a * multiline comment * comment in C */ The asterisks at the beginning of each line inside the multi-line comment are customary, but not required. C does not have a dedicated single-line comment syntax. C++ //This is a comment in C++ /* * This is a * multi-line comment * in C++ */ The asterisks at the beginning of each line inside the multi-line comment are customary, but not required. Java, C++, JavaScript, and C# use the same syntax. C# //This is a comment in C# /* * This is a * multi-line comment * in C# */ The asterisks at the beginning of each line inside the multi-line comment are customary, but not required. Java, C++, JavaScript, and C# use the same syntax. JavaScript //This is a comment in JavaScript /* * This is a * multi-line comment * in JavaScript */ The asterisks at the beginning of each line inside the multi-line comment are customary, but not required. Java, C++, JavaScript, and C# use the same syntax. VB.NET â€˜This is a comment in VB.NET â€˜This is a â€˜multiline comment â€˜in VB.NET VB.NET has no special way of creating multi-line comments. Matlab %This is a comment in Matlab %{ This is a multiline comment in Matlab %} Swift //This is a comment in Swift /* This is a multi-line comment in Swift */ Ruby # This is a comment in Ruby =begin This is a multiline comment in Ruby =end Ruby is weird. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:13:2","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Variable Declarations and Assignments Note that in Python, we create a variable by assigning it an initial value. In other languages, itâ€™s possible to create a variable without assigning it any value. Language Syntax Notes Python my_int = 5 my_str = â€œHello world!â€ Python prefers snake_case for variable style. Java int myVar = 5; string myStr = â€œHello world!\"; The first item in the variable declaration line (int,Â string, etc.) is the data type. The variable cannot change types once declared to be a certain type. Java prefers camelCase for variable names. C, C++, C# int myVar = 5; string myStr = â€œHello world!\"; The first item in the variable declaration line (int,Â string, etc.) is the data type. The variable cannot change types once declared to be a certain type. C prefers camelCase for variable names. JavaScript var myVar = 5; var myStr = â€œHello world!\"; varÂ is used whenever creating a new variable, but it does not represent a type. JavaScript prefers camelCase for variable names. VB.NET Dim MyVar As Integer = 5 Dim MyStr As String = â€œHello world!â€ types (As Integer,Â As String) are optional but recommended in VB.NET. VB.NET prefers camelCase for variable names, but often capitalizes the first letter, too (e.g.Â MyVarÂ instead ofÂ myVar). Matlab my_var = 5 my_str = â€œHello world!â€ Matlab has few consistent variable name styles. Swift var myVar = 5 var myStr = â€œHello world!â€ Swift prefers camelCase for variable names. Ruby my_var = 5 my_str = â€œHello world!â€ Ruby prefers snake_case for variable names. Many languages (Java, C/C++/C#, VB.NET) are statically typed, meaning that once when you create a variable, you have to decide what its type will be. Afterward, it can never take a different type. Other languages (Python, Swift, Ruby, JavaScript) are dynamically typed, meaning that a variableâ€™s type comes from its value. If you change its value, the variableâ€™s type can change. ","date":"2021-10-21","objectID":"/gatech-cs1301xi/:13:3","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"Operators The rules of logic are generally the same across all programming languages. Pythonâ€™sÂ operator precedenceÂ is relatively universal, although there can be slight differences (for example, not all languagesÂ haveÂ slicing, subscription, or lambda expressions). The syntax used for various operators, however, can differ. Relational Operators Most relational operators are the same in all languages. These are the same in Python, Java, C, C++, C#, JavaScript, VB.NET, Matlab, Swift, and Ruby: a \u003c b: Less than a \u003c= b: Less than or equal to a == b: Equal to a \u003e= b: Greater than or equal to a \u003e b: Greater than IfÂ aÂ andÂ bÂ are not the same type, JavaScript will automatically try to convert them to the same type before comparison. To avoid this conversion, youâ€™d useÂ ===. The languages differ a little bit more with the â€˜not equal toâ€™ operator: Language Syntax Notes Python, Java, C, C++, C# a != bÂ  JavaScript a != bÂ  IfÂ aÂ andÂ bÂ are not the same type, JavaScript will automatically try to convert them to the same type before comparison. To avoid this conversion, youâ€™d useÂ !==. VB.NET a \u003c\u003e b Technically, theÂ \u003c\u003eÂ operator works in most other languages as well for not equal to, butÂ !=Â is more common. Matlab a ~= b Boolean Operators The three boolean operatorsâ€“and, or, notâ€“are generally represented in one of three ways: with symbols, with double-symbols, or with plaintext words. Different languages also use slightly different capitalizations for booleans, so weâ€™ll use the language-appropriate ones here, too. Language Syntax Notes Python True and FalseÂ #And True or False #Or not True #Not You can also use \u0026 (for and) and ` Java true \u0026\u0026 falseÂ #And true ` C 1 \u0026\u0026 0Â #And 1 ` C++, C# true \u0026\u0026 falseÂ #And true ` JavaScript true \u0026\u0026 falseÂ #And true ` VB.NET True And FalseÂ #And True Or False #Or Not True #Not True Xor FalseÂ #Exclusive-Or Following its style, VB.NET capitalizes both the boolean values and the logical operators. It also offers an exclusive-or operator. It also includes two additional operators, AndAlso and OrElse, which function like \u0026\u0026 and ` Matlab true \u0026 falseÂ #And true ` false #Or\u003cbr\u003e~true #Not\u003cbr\u003etrue xor` falseÂ #Exclusive-Or Swift true \u0026\u0026 falseÂ #And true ` Ruby true and falseÂ #And true \u0026\u0026 falseÂ #Also And true or falseÂ #Or true ` Mathematical Operators Most languages share the same mathematical operators: itâ€™s hard to get away from plus for addition, minus for subtraction, etc. There are some unique ones, though: floor division, modulus, and exponentiation may differ by language. Language Syntax Notes Python a // bÂ #Floor Division a ** bÂ #Exponentiation, a to the b a % bÂ #Modulus Java a / bÂ //See notes a % bÂ //Modulus Java has no floor division operator, but it does not automatically convert to floating point numbers either. If you divide two integers, it will round down like floor division. If either number is a decimal number, the result will be the real quotient. Java has no exponent operator: instead it would useÂ Math.pow(a, b). C, C++, C# a / bÂ /* See notes */ a % bÂ /* Modulus */ Câ€™s (and its derivativesâ€™) floor division works like Javaâ€™s: if the numbers are integers, it will perform floor division, but if not, it will return a decimal number. C has no exponent operator, and instead uses separate functions. JavaScript a % bÂ //Modulus JavaScript has neither a floor division operator nor an exponent operator. It uses separate functions for both. VB.NET a \\ bÂ â€˜Floor division a ^ bÂ â€˜Exponentiation, a to the b a mod b â€˜Modulus VB.NETâ€™s operator for modulus is just the keywordÂ mod. Matlab a .^ bÂ %Exponentiation, a to the b Matlab has no dedicated operators for floor division and modulus; it uses functions instead. Swift a % bÂ ///Modulus Swift has no dedicated exponentiation or floor division operator; it uses functions instead. Ruby a / bÂ #See notes a ** bÂ #Exponentiation, a to the b a % bÂ #Modulus Rubyâ€™s division operator works like C and Java: if the numbers are integers it performs floor division, otherwise it performs regular divisio","date":"2021-10-21","objectID":"/gatech-cs1301xi/:13:4","tags":null,"title":"Gatech CS1301xI","uri":"/gatech-cs1301xi/"},{"categories":null,"content":"å‰è¨€ äººä»¬æˆ–è®¸å¬è¯´è¿‡ ã€Šé©¬å¤ªç¦éŸ³ã€‹ğŸ“•ï¼Œä¹Ÿå¬è¯´è¿‡ â€œé©¬å¤ªæ•ˆåº”â€ã€‚ä½†æ˜¯ï¼Œå…³äºã€é©¬å¤ªã€‘è¿™ä¸ªäººï¼Œå´çŸ¥ä¹‹å¯¥å¯¥ã€‚ã€åœ£é©¬å¤ªã€‘(Saint Matthew) æ˜¯åŸºç£è€¶ç¨£çš„åäºŒä½¿å¾’ä¹‹ä¸€ï¼Œä¹Ÿæ˜¯ç¬¬ä¸€å·ç¦éŸ³ä¹¦çš„ä½œè€…ã€‚åœ¨æˆä¸ºè€¶ç¨£çš„é—¨å¾’ä¹‹å‰ï¼ŒçŠ¹å¤ªäººé©¬å¤ªæ˜¯è¿¦ç™¾å†œçš„ä¸€åç¨åğŸ’°ï¼Œä»–ç»ˆæ—¥ååœ¨ç½—é©¬ç¨å…³ä¹‹ä¸Šï¼Œæ‹›å‘¼ç€è¿‡å¾€çš„äººä»¬ç¼´ç¨ã€‚è€Œ â€œé©¬å¤ªæ•ˆåº”â€ åˆ™å‡ºè‡ª ã€Šæ–°çº¦Â·é©¬å¤ªç¦éŸ³ã€‹ ä¸­çš„ä¸€å¥è¯ï¼š å‡¡æœ‰çš„ï¼Œè¿˜è¦åŠ å€ç»™ä»–å«ä»–å¤šä½™ï¼›æ²¡æœ‰çš„ï¼Œè¿ä»–æ‰€æœ‰çš„ä¹Ÿè¦å¤ºè¿‡æ¥ã€‚ é©¬å¤ªå—è€¶ç¨£æ„Ÿå¬çš„åœºæ™¯æˆä¸ºåä¸–è‰ºæœ¯å®¶ä»¬æ´¥æ´¥ä¹é“çš„é¢˜æã€‚åœ¨ ã€Šé©¬å¤ªç¦éŸ³ã€‹ ä¸­ï¼Œå¯¹è¿™ä¸ªå‘½è¿è½¬å˜æ—¶åˆ»çš„è®°å½•ååˆ†ç®€ç•¥ï¼š è€¶ç¨£ä»é‚£é‡Œå¾€å‰èµ°ï¼Œçœ‹è§ä¸€ä¸ªäººç¨åï¼Œåå«åˆ©æœªï¼Œååœ¨ç¨å…³ä¸Šï¼Œå°±å¯¹ä»–è¯´ï¼Œä½ è·Ÿä»æˆ‘æ¥ã€‚ä»–å°±èµ·èº«è·Ÿä»äº†è€¶ç¨£ã€‚ ã€å¡æ‹‰ç“¦ä¹”ã€‘éå¸¸è®¤åŒå…¶ä¸­çš„æ€æƒ³ï¼Œå› ä¸ºè‡ªèº«æ€§æ ¼å’Œç›¸å…³ç»å†ï¼Œä»–å¾ˆæ“…é•¿åˆ»ç”»æŸç§å¯èƒ½çš„==æ•‘èµ==ï¼Œè¿™ç§æ•‘èµè½åœ¨æœ€ä¸å¯èƒ½ã€æœ€é¡½å›ºçš„==ç½ªäºº==èº«ä¸Šã€‚è¿™å¹…ç”»ä¸­ï¼Œä»–æç»˜çš„æ˜¯è‡ªå·±çš„æœ¬æ€§ï¼Œæ˜¯è‡ªå·±ç†Ÿæ‚‰çš„äººç‰©ï¼Œæ˜¯ç½—é©¬ç°å®ç”Ÿæ´»ä¸­çš„åœºæ™¯ï¼Œå› è€Œå½“æ—¶çš„çœ‹ç”»äººä¹Ÿä¼šè§‰å¾—ï¼Œå¡æ‹‰ç“¦ä¹”çš„è¿™å¹…ç”»è¿æ¥äº†å†å²ä¸å½“ä¸‹ï¼Œä¹Ÿè¿æ¥äº†å¹³å‡¡ä¸ç¥åœ£ã€‚ ç”»é¢æ•´ä½“ å¡æ‹‰ç“¦ä¹”å¹¶æ²¡æœ‰æ²¿ç”¨åœ£ç»ä¸­æ‰€æè¿°çš„åœ°ç‚¹ï¼Œè€Œæ˜¯åˆ›é€ æ€§åœ°æŠŠåœºæ™¯è®¾ç½®åœ¨ä¸€ä¸ªé˜´æš—çš„è§’è½é‡Œï¼Œæˆ‘ä»¬å¾ˆéš¾åˆ†è¾¨è¿™æ˜¯å®¤å†…è¿˜æ˜¯å®¤å¤–ï¼Œæˆ–è®¸æ˜¯ç ´æ—§çš„é…’é¦†ï¼Œç”šè‡³å¯èƒ½æ˜¯èµŒåœºçš„ä¸€éš…ã€‚ä»–å°†åœ£é©¬å¤ªè’™å¬è¿™ä¸€ç¬é—´è¡¨ç°ä¸ºä¸€ç§==è¿‘ä¹æ— å£°çš„ã€æˆå‰§æ€§çš„å™è¿°==ï¼Œä»¿ä½›ä¸€åˆ‡åŠ¨æ€éƒ½åœ¨ä¸€ç¬é—´è¢«å®šæ ¼ã€‚æ”¶ç¨äººã€åˆ©æœªã€‘ï¼ˆLeviï¼Œåœ£é©¬å¤ªæˆä¸ºä½¿å¾’ä¹‹å‰çš„åå­—ï¼‰å’Œä»–çš„å››ä¸ªéšä»å›´ååœ¨ä¸€å¼ æ¡Œå­æ—ï¼Œæ¡Œä¸Šéšæ„æ•£è½ç€é‡‘å¸ï¼Œä»–ä»¬ä¼¼ä¹æ­£åœ¨ä¸“å¿ƒè‡´å¿—åœ°æ•°ç€å½“å¤©çš„æ”¶å…¥ã€‚ çªç„¶ï¼Œä¸€æŸå…‰è‡ªå³ä¸Šè§’å°„å…¥ï¼Œç…§äº®äº†è¿™ç¾¤äººï¼›é¡ºç€å…‰æºçš„æ–¹å‘ï¼Œæˆ‘ä»¬å°±èƒ½çœ‹è§è€¶ç¨£â€”â€”ä»–ä¸ã€åœ£å½¼å¾—ã€‘ä¸€åŒè¿›å…¥ï¼Œèº«ç€å¤æ—§çš„è¢å­ï¼Œèµ¤è£¸åŒè„šï¼Œçœ‹ä¸Šå»ä¸å‡¡äººåˆ«æ— äºŒæ ·ï¼Œå”¯æœ‰ ==å¤´é¡¶çš„å…‰ç¯==æš—ç¤ºç€ä»–çš„ç¥æ€§ğŸ˜‡ã€‚ä»– ==å³æ‰‹==å¬å”¤é©¬å¤ªçš„æ‰‹åŠ¿ï¼Œä»¿ä½›ç”±äºæ— åŠ›å’Œç–²å€¦è€Œæ˜¾å¾—æ›´åŠ å…·æœ‰ç¥çš„åŠ›é‡ï¼Œå¼•äººæ³¨ç›®ã€‚é©¬å¤ªå¯¹è¿™ä¸¤ä½é™Œç”Ÿäººçš„é—¯å…¥æ„Ÿåˆ°æƒŠè®¶Î£(ã£ Â°Ğ” Â°;)ã£ï¼Œä¹Ÿå¯èƒ½æ˜¯è¢«çªç„¶å°„å…¥çš„å¼ºå…‰ç‚«å¾—çœ¼èŠ±ç¼­ä¹±ã€‚ä»–èº«ä½“åå€¾ï¼Œç”¨ ==å·¦æ‰‹==æŒ‡äº†æŒ‡è‡ªå·±ğŸ‘ˆï¼Œå¥½åƒåœ¨è¯´ï¼Œâ€œè°ï¼Ÿæˆ‘ï¼Ÿâ€ï¼Œè€Œä»–çš„ ==å³æ‰‹==ä»åœç•™åœ¨æ­£åœ¨æ•°ç€çš„é‡‘å¸ä¸Šï¼Œè¿˜æ²¡æ¥å¾—åŠååº”ã€‚åœ£å½¼å¾—ä¹ŸæŒ‡å‘é©¬å¤ªï¼ŒåŒæ—¶è½¬èº«å¯¹ç€è€¶ç¨£ï¼Œä¼¼ä¹åœ¨é—®ï¼šâ€œæ˜¯ä»–å—ï¼Ÿâ€ğŸ¤”â€œå¯¹ï¼Œå°±æ˜¯ä½ ï¼Œé©¬å¤ªï¼â€è¿™ä¸‰ä¸ªäººçš„æ‰‹åŠ¿è®©ç”»é¢ä¸Šçš„æ•…äº‹é¡¿æ—¶ç”ŸåŠ¨èµ·æ¥ï¼Œä¹Ÿå°†é©¬å¤ªä»ä¸–ä¿—ç”Ÿæ´»ä¸­å‰¥ç¦»å‡ºæ¥ï¼Œä»æ­¤ç¨ååˆ©æœªæˆä¸ºåœ£å¾’é©¬å¤ªã€‚ è¿™æ ·çš„åœºæ™¯å¥½ä¼¼ç°ä»£ç”µå½±ä¸­çš„ä¸€ä¸ªé•œå¤´ğŸ“½ï¸ï¼Œå……æ»¡äº†æˆå‰§æ€§å’Œç´§è¿«æ„Ÿï¼Œå®ƒä¹Ÿæ˜¯å¡æ‹‰ç“¦ä¹”ä½œå“æœ€å…·ä»£è¡¨æ€§çš„é£æ ¼ï¼Œè®©è§‚ä¼—ä»¿ä½›ç½®èº«ç”»ä¸­ï¼Œåˆ‡èº«æ„Ÿå—åˆ°å½“æ—¶çš„æ°”æ°›ã€‚ ç»†èŠ‚è§£è¯» ","date":"2021-10-18","objectID":"/the-calling-of-saint-mathew/:0:0","tags":null,"title":"å¡æ‹‰ç“¦ä¹”ã€Šåœ£é©¬å¤ªè’™å¬ã€‹","uri":"/the-calling-of-saint-mathew/"},{"categories":null,"content":"æ¡Œå­å·¦è¾¹çš„æ•°é‡‘å¸è€… é¦–å…ˆï¼Œæˆ‘ä»¬æ¥æ‰“é‡ä¸€ä¸‹å·¦è¾¹è¿™ä¸¤ä¸ªå¤´ä¹Ÿä¸æŠ¬ï¼Œä¸€å¿ƒæ•°ç€é‡‘å¸çš„äººã€‚å…¶ä¸­ä¸€ä¸ªå¹´é•¿ä¸€äº›çš„ï¼ŒåŠå¼“ç€è…°ï¼Œçœ‰å¤´ç´§é”ï¼Œä¸¥è‚ƒåœ°æŠ¿ç€å˜´ã€‚è€¶ç¨£çš„åœ£å…‰ç…§å¾—ä»–é‚£é¡¶ç€ç¨€ç¨€ç–ç–é“¶å‘çš„è„‘é—¨å­é—ªé—ªå‘å…‰ã€‚ä»–ç”¨æ‰‹æ‰¶äº†æ‰¶çœ¼é•œï¼ŒæåŠ›æƒ³æ•°æ¸…æ¡Œä¸Šé‡‘å¸çš„æ•°ç›®ï¼Œä»¿ä½›å¿ƒé‡Œé¢åœ¨ç›˜ç®—ç€è‡ªå·±èƒ½åˆ†åˆ°å¤šå°‘é“¶ä¸¤ã€‚ä»–åœ¨è§†åŠ›å’Œé“å¾·ä¸Šéƒ½æ˜¯æå…¶çŸ­è§†çš„ã€‚ å¦ä¸€ä½ååœ¨æ¡Œå­æœ€å·¦ä¾§ã€ä½ç€å¤´çš„å°ä¼™ï¼Œçœ¼ç›æ­»æ­»åœ°ç›¯ç€æ¡Œä¸Šçš„é‡‘å¸ï¼ŒåŒè‚˜å°†èº«ä½“æ’‘åœ¨æ¡Œå­è¾¹ç¼˜ï¼Œå·¦æ‰‹æ”¯åœ¨å³è‡‚åæ–¹ï¼Œå³æ‰‹è½»è½»æ­åœ¨æ¡Œä¸Šï¼Œæ•´ä½“å‘ˆç°å‡ºè ¢è ¢æ¬²åŠ¨çš„çŠ¶æ€ï¼Œå¥½åƒä¸‹ä¸€ç§’å°±è¦ä¼¸æ‰‹å»æ‹¿é‡‘å¸ã€‚è¿™ä¸¤ä¸ªäººå¦‚æ­¤å…³å¿ƒæ•°é’±ï¼Œä»¥è‡³äºä»–ä»¬ç”šè‡³æ²¡æœ‰æ³¨æ„åˆ°è€¶ç¨£çš„åˆ°æ¥ï¼Œä»–ä»¬å¯¹åŸºç£çš„æ¼ è§†å‰¥å¤ºäº†ä»–ä»¬è·å¾—æ°¸ç”Ÿçš„æœºä¼šã€‚ æŸäº›è‰ºæœ¯å²å­¦å®¶è®¤ä¸ºï¼Œè¿™ä¸¤ä¸ªäººç‰©å¯èƒ½åœ¨æŸç§ç¨‹åº¦ä¸Šå—åˆ°äº†ã€å°æ±‰æ–¯Â·éœå°”æ‹œå› ã€‘ (Hans Holbein the Younger) çš„å¯å‘âœ¨ã€‚åœ¨è·å°”æ‹œå› çš„ ==æœ¨ç‰ˆç”»ã€Šæ­»äº¡ä¹‹èˆã€‹ä¹‹åä¸€ã€ŠèµŒå¾’ã€‹== ä¸­ï¼Œä¸‰åèµŒå¾’ååœ¨æ¡Œå­æ—è¾¹ï¼Œæ­»ç¥å’Œé­”é¬¼ä¸ºäº†æŠ¢å¤ºä¸­é—´è¿™åèµŒå¾’è€Œäº§ç”Ÿäº†äº‰æ‰§ï¼Œå·¦è¾¹çš„è¿™ä¸€ä½ä¼¼ä¹åœ¨æ›¿ä»–çš„åŒä¼´å‘æ­»ç¥è¯´æƒ…ï¼Œè€Œå³è¾¹çš„è¿™ä¸€ä½åˆ™é—·ç€å¤´è®¡ç®—ç€è´¦ç›®ï¼Œä¸æ¯«æœªæ³¨æ„åˆ°æ­»ç¥å’Œé­”é¬¼æ­£åœ¨å¤ºå–ä»–çš„æœ‹å‹ã€‚è¿™å¹…ç”»ä»¥ä¸€ç§ç±»ä¼¼é»‘è‰²å¹½é»˜çš„æ‰‹æ³•ï¼Œç”ŸåŠ¨åœ°è®½åˆºäº†å³è¾¹è¿™ä½èµŒå¾’å¯¹é‡‘é’±çš„ç—´è¿·ï¼Œä»¥è‡´äºå®Œå…¨å¿½è§†äº†æ­»ç¥å’Œé­”é¬¼çš„é™ä¸´ã€‚ ","date":"2021-10-18","objectID":"/the-calling-of-saint-mathew/:1:0","tags":null,"title":"å¡æ‹‰ç“¦ä¹”ã€Šåœ£é©¬å¤ªè’™å¬ã€‹","uri":"/the-calling-of-saint-mathew/"},{"categories":null,"content":"æ¡Œå­å³è¾¹çš„å¹´è½»ç”·å­© æ¡Œå­å³è¾¹çš„ä¸¤ä¸ªç”·å­©ç¡®å®å¯¹è€¶ç¨£çš„åˆ°æ¥åšå‡ºäº†å›åº”ã€‚é¢å‘æˆ‘ä»¬çš„ã€ç¨æ˜¾å¹´è½»çš„è¿™ä¸€ä¸ªï¼Œç²‰å«©çš„å°è„¸è›‹è¢«åœ£å…‰ç…§å¾—é€šäº®ï¼Œä»–ç›®ä¸è½¬ç›åœ°çœ‹ç€ä¸¤ä½â€œä¸é€Ÿä¹‹å®¢â€ï¼Œä¸‹æ„è¯†åœ°é å‘äº†é©¬å¤ªï¼Œä»¥å¯»å¾—ä¸€ä¸å®‰å…¨æ„Ÿã€‚ä»–çš„æ‰‹è‡‚æ­åœ¨é©¬å¤ªçš„è‚©è†€ä¸Šï¼Œå¥½åƒåœ¨è¯´ï¼šâ€œå¤§å“¥ï¼Œè¿™ä¸¤ä¸ªäººæ˜¯ä¸æ˜¯æ¥æ‰¾ä½ çš„å•Šï¼Ÿâ€ å®é™…ä¸Šï¼Œæ­£è„¸é¢å‘æˆ‘ä»¬çš„ç”·å­©ï¼Œæ˜¯å¡æ‹‰ç“¦ä¹”éå¸¸å–œçˆ±çš„ä¸€åç”·æ¨¡ç‰¹ï¼Œ ==ã€é©¬é‡Œå¥¥Â·æ˜å°¼è’‚ ã€‘(Mario Minniti)==ï¼Œä»–æ›¾åœ¨å¡æ‹‰ç“¦ä¹”çš„å¤šå¹…ä½œå“ä¸­å‡ºç°è¿‡ï¼ŒåŒ…æ‹¬ï¼š ã€Šæ§ç€æ°´æœç¯®çš„ç”·å­©ã€‹ï¼Œ1593ï¼Œ Boy with a Basket of Fruit 1593 ã€Šç®—å‘½è€…ã€‹ï¼Œ1594 \u0026 1599ï¼ŒThe Fortune Teller 1599 ã€Šè€åƒã€‹ï¼Œ1594, ä¸¤ä¸ªäººç‰©åŒä¸€ä¸ªæ¨¡ç‰¹ï¼ŒCardsharps 1594 ã€ŠéŸ³ä¹å®¶ã€‹ï¼Œ1595ï¼Œä¸¤ä¸ªäººç‰©åŒä¸€ä¸ªæ¨¡ç‰¹Musicians 1595 ã€Šé…’ç¥å·´åº“æ–¯ã€‹ï¼Œ1596ï¼ŒBacchus 1596 ã€Šè¢«èœ¥èœ´å’¬ä¼¤çš„ç”·å­©ã€‹ï¼Œ1596ï¼ŒBoy Bitten by a Lizard 1596 ã€Šé²ç‰¹ç´æ¼”å¥è€…ã€‹ï¼Œ1596ï¼ŒæŸæ˜é¡¿åº„å›­ç‰ˆï¼ŒThe Lute Player 1596, Ex-Badminton House, Gloucestershire ã€Šé²ç‰¹ç´æ¼”å¥è€…ã€‹ï¼Œ1596ï¼ŒWildensteinç‰ˆï¼ŒThe Lute Player 1596, Private Collection. Wildenstein Collection ã€Šåœ£é©¬å¤ªè’™å¬ã€‹ï¼Œ1599ï¼ŒCalling of Saint Matthew 1599 ã€Šåœ£é©¬å¤ªæ®‰éš¾ã€‹ï¼Œ1599ï¼ŒMartyrdom of Saint Matthew 1599 è¿™é‡Œæ”¾ä¸Šå…³äºæ˜å°¼è’‚çš„ä¸€äº›è¡¥å……ä»‹ç»ï¼Œä¸»è¦èŠäº†æ˜å°¼è’‚ä½œä¸ºå¡æ‹‰ç“¦ä¹”çš„â€œå¾¡ç”¨â€æ¨¡ç‰¹ï¼Œéƒ½â€œå‚æ¼”è¿‡â€å“ªäº›ç”»ä½œï¼Œæ„Ÿå…´è¶£çš„æœ‹å‹å¯ä»¥ç§»æ­¥è¿™ç¯‡æ–‡ç« ã€‚ Mario Minniti as a model in Caravaggioâ€™s works è€ŒèƒŒå¯¹æˆ‘ä»¬çš„ã€ç¨æ˜¾å¹´é•¿çš„é‚£ä¸€ä¸ªç”·å­©ï¼Œåˆ™å¤šäº†å‡ åˆ†ç—æ°”ã€‚ä»–ä¸ŠåŠèº«ç•¥å¸¦å¨èƒåœ°å‘ç€ä¸¤ä½é™Œç”Ÿäººè½¬å»ï¼Œå·¦æ‰‹ä¸‹æ„è¯†åœ°æ‘¸å‘è…°é—´çš„ä½©å‰‘ğŸ—¡ï¼Œå³æ‰‹æ’‘ç€å‡³å­çš„ä¸€è§’ï¼Œè…¿éƒ¨è‚Œè‚‰å’Œè·Ÿè…±ç»·ç´§ï¼Œå·¦è„šç‚¹åœ°ï¼Œä»¿ä½›å°±è¦èµ·èº«ã€‚ä½œä¸ºå…¨åœºå”¯ä¸€ä¸€ä¸ªä½©æˆ´äº†æ­¦å™¨çš„äººï¼Œä»–ä»¿ä½›æ˜¯ä¸“é—¨ååœ¨é—¨å£ä»¥é˜²â€œåˆ†èµƒâ€è¿‡ç¨‹è¢«æ‰“æ–­çš„â€œä¿å®‰â€ğŸ›¡ï¸ï¼Œè¿™æ ·çœ‹æ¥ï¼Œä»–çš„è­¦è§‰å’Œæ•Œæ„å°±æ˜¾å¾—ååˆ†è‡ªç„¶äº†ã€‚ ","date":"2021-10-18","objectID":"/the-calling-of-saint-mathew/:2:0","tags":null,"title":"å¡æ‹‰ç“¦ä¹”ã€Šåœ£é©¬å¤ªè’™å¬ã€‹","uri":"/the-calling-of-saint-mathew/"},{"categories":null,"content":"ä»åˆ©æœªåˆ°åœ£é©¬å¤ª æˆ‘ä»¬å¯èƒ½ä¼šæ„Ÿåˆ°ç–‘æƒ‘ğŸ¤”ï¼šä¸ºä»€ä¹ˆç”»é¢ä¸­çš„é©¬å¤ªä¸€è„¸è®¶å¼‚ï¼Œä¸ºä»€ä¹ˆåœ£å½¼å¾—è¦åå¤è¿½é—®ï¼Ÿ åŸæ¥ï¼Œç¨åè¿™ä¸€èŒä¸šåœ¨å½“æ—¶äººä»¬å¿ƒç›®ä¸­æ˜¯ååˆ†ç½ªæ¶çš„ï¼Œç¨åé©¬å¤ªæ— ç–‘ä¼šè¢«äººå½“ä½œç½ªäººã€‚è€Œåœ£äººè€¶ç¨£ç«Ÿç„¶æ„¿æ„æ„Ÿå¬ä¸€åç½ªäººï¼Œå°±è¿é©¬å¤ªè‡ªå·±ä¹Ÿæ„Ÿåˆ°è¯šæƒ¶è¯šæã€‚ğŸ˜± ç½—é©¬å…±å’Œå›½æ—¶æœŸï¼Œä¸€æ–¹é¢ï¼Œå›½åœŸä¸æ–­æ‰©å¼ ï¼Œå¤§é‡çš„è´¢å¯Œä¸äººå£æ¶Œå…¥ç½—é©¬ï¼Œè´¢æ”¿äº‹åŠ¡å¤æ‚ï¼›å¦ä¸€æ–¹é¢ï¼Œç³»ç»Ÿå®Œå¤‡çš„è´¢æ”¿ç®¡ç†æœºæ„å’Œåˆ¶åº¦å§‹ç»ˆæ²¡æœ‰å½¢æˆï¼Œç®¡ç†æ°´å¹³ä½ä¸‹ã€‚å¤§é‡çš„è´¢å¯Œèµ„æºå¾—ä¸åˆ°æœ‰æ•ˆåˆç†çš„å®‰æ’ä¸åˆ©ç”¨ï¼Œä¸¥é‡é˜»ç¢äº†ç½—é©¬ç»æµçš„å¥åº·å‘å±•ã€‚ç¨è´ŸåŠ é‡ï¼Œäººæ°‘ç”Ÿæ´»æ—¥ç›Šè´«å›°ï¼Œæ¶ˆè´¹å¸‚åœºæ—¥æ¸èç¼©ï¼Œå†œä¸šè¡°è½åˆä½¿å·¥å•†ä¸šç”Ÿäº§åŸæ–™å‡å°‘ï¼Œè€Œæ‰‹å·¥ä¸šå’Œå•†ä¸šçš„è¡°è½è¿›ä¸€æ­¥å½±å“åˆ°å¸å›½çš„ç¨æ”¶æ”¶å…¥ï¼Œæœ€ç»ˆå¸å›½çš„ç¨æ”¶ä¸è´¢æ”¿åˆ°äº†å´©ç›˜çš„è¾¹ç¼˜ã€‚å› æ­¤ï¼Œè¿™ä¸ªæ—¶ä»£çš„ç¨åå®å±ç½ªå¤§æ¶æçš„èŒä¸šã€‚ğŸ˜ˆ å¦ä¸€æ–¹é¢ï¼Œè¿™ä¹Ÿä½“ç°äº†è€¶ç¨£çš„æ€œæ‚¯ã€‚é©¬å¤ªç¦éŸ³ä¸­è®°è½½äº†åœ£é©¬å¤ªè’™å¬ä¹‹åçš„ä¸€æ®µæ•…äº‹ï¼š ä¸ºäº†æ„Ÿè°¢ä»–ï¼ˆè€¶ç¨£ï¼‰ï¼Œé©¬å¤ªåœ¨ä»–å®¶é‡Œä¸¾è¡Œäº†ç››å¤§çš„å®´ä¼šã€‚æœ‰å¥½å‡ ä¸ªç¨åå’Œç½ªäººå’Œè€¶ç¨£ä¸ä»–çš„é—¨å¾’ååœ¨ä¸€èµ·ã€‚æ³•åˆ©èµ›äººå’Œä»–ä»¬çš„æ–‡å£«çœ‹è§äº†ï¼Œå°±é—®è€¶ç¨£çš„é—¨å¾’ï¼šâ€œä½ ä»¬çš„ä¸»äººä¸ºä»€ä¹ˆä¸ç¨åå’Œç½ªäººä¸€èµ·åƒé¥­å‘¢ï¼Ÿâ€å½“ä»–å¬åˆ°è¿™å¥è¯æ—¶ï¼Œä»–å›ç­”è¯´ï¼šâ€œéœ€è¦åŒ»ç”Ÿçš„ä¸æ˜¯å¥åº·çš„äººï¼Œè€Œæ˜¯ç—…äººã€‚å»å­¦ä¹ è¿™å¥è¯çš„æ„æ€ï¼šæ€œæ‚¯æ˜¯æˆ‘æ‰€å–œæ‚¦çš„ï¼Œè€Œä¸æ˜¯ç‰ºç‰²ã€‚çš„ç¡®ï¼Œæˆ‘ä¸æ˜¯æ¥å¬å«æ­£ç›´äººï¼Œè€Œæ˜¯å¬å«ç½ªäººã€‚â€ æˆ‘ä»¬å†å›åˆ°ç”»é¢ï¼Œå½“â€œä¿¡ä»°ä¹‹å…‰â€âœ¨æ‰“åœ¨é©¬å¤ªå›°æƒ‘çš„è„¸ä¸Šï¼Œä»–çš„ä¸¤é¢Šç”±äºå¿½è¢«â€œç‚¹åâ€è€Œå˜å¾—é€šçº¢ã€‚å¯¹äºç¥åœ£çš„å¬å”¤ï¼Œä»–åšå‡ºäº†æ¯ä¸ªç½—é©¬äººã€æ¯ä¸ªæœåœ£è€…éƒ½ä¼šè®¤å‡ºçš„ååº”ï¼šâ€œä»€ä¹ˆï¼Ÿæˆ‘ï¼Ÿâ€æœ‰äº›å­¦è€…è¯´ï¼Œæ­¤å¤„çš„åœ£é©¬å¤ªæ˜¯è°å…¶å®éš¾ä»¥ç¡®å®šã€‚ä¹Ÿè®¸è¿™ä½å¤§èƒ¡å­ç”·ğŸ§”ğŸ¼æŒ‡å‘çš„æ˜¯å¦ä¸€ä¸ªäººâ€”â€”æ¡Œå­å°½å¤´å¼“ç€èƒŒçš„å¹´è½»äººï¼Œå˜´é‡Œè¯´çš„æ˜¯ï¼šâ€œä½ æ˜¯æŒ‡ä»–å—ï¼Ÿâ€ï¼ˆæš—ç¤ºè¿™ä½å¹´è½»äººæ˜¯é©¬å¤ªï¼‰ï¼›è¿˜æœ‰ä¸€äº›äººè®¤ä¸ºå¡æ‹‰ç“¦ä¹”çš„ç”»æ˜¯æ•…æ„æ¨¡æ£±ä¸¤å¯çš„ã€‚ä½†åœ¨æˆ‘è€Œè¨€ï¼Œæ¯«æ— ç–‘é—®ï¼Œå³å°†æˆä¸ºé—¨å¾’é©¬å¤ªçš„å°±æ˜¯è¿™ä¸ªæ»¡è„¸èƒ¡é¡»çš„äººã€‚å› ä¸ºä»–è¡£ç€åä¸½ï¼Œä¹Ÿæ˜¯å¡æ‹‰ç“¦ä¹”è‡ªå·±æœ€å–œæ¬¢çš„é»‘å¤©é¹…ç»’ï¼Œè¿™å°±ä½¿å¾—ç¨åå‘è°¦å‘çš„çšˆä¾æ›´åŠ ç”ŸåŠ¨ã€‚ ","date":"2021-10-18","objectID":"/the-calling-of-saint-mathew/:3:0","tags":null,"title":"å¡æ‹‰ç“¦ä¹”ã€Šåœ£é©¬å¤ªè’™å¬ã€‹","uri":"/the-calling-of-saint-mathew/"},{"categories":null,"content":"è€¶ç¨£å³æ‰‹ä¸å¤´é¡¶çš„åœ£å…‰ åŸºç£æ²¡æœ‰åœ¨ç”»é¢æ­£ä¸­ï¼Œè€Œæ˜¯èº«å¤„é»‘æš—ï¼Œè¿™å¼•å¾—è§‚è€…å»å¯»æ‰¾ä»–çš„å­˜åœ¨ã€‚è€Œé‚£æŸå…‰ç»™äº†æˆ‘ä»¬ç»å¦™çš„æç¤ºã€‚ä»ç¥å­¦è§’åº¦è¯´ï¼Œè¿™æ˜¯å®Œç¾çš„å¤„ç†ï¼Œå› ä¸ºåœ£å½¼å¾—ä»‹äºä¼—äººå’ŒåŸºç£ä¹‹é—´ï¼Œå°±åƒä»–åœ¨æ•™ä¼šåˆ¶åº¦ä¸­çš„ä½œç”¨ä¸€æ ·ã€‚è¿™ç§å¤„ç†åœ¨å¿ƒç†å±‚é¢ä¹Ÿå¾ˆå‡ºè‰²ï¼Œå› ä¸ºåŸºç£ä»…ä»…å±•ç°å‡ºéƒ¨åˆ†èº«ä½“ï¼Œè¿™å°±å°†å¤§å®¶çš„æ³¨æ„åŠ›éƒ½æ”¾åœ¨ä¸€ä¸ªæ— æ³•å¿½è§†çš„éƒ¨ä½ï¼šä»–ä¼¸å‡ºçš„èƒ³è†Šå’Œæœ‰æŒ‡å‘çš„æ‰‹æŒ‡ã€‚è¿™æ˜¯ç¥åœ£ä¸ä¸–ä¿—çš„å®Œç¾ç»“åˆï¼Œè€Œä¸”ä¹Ÿæ­£æ˜¯æ•´ä¸ªæ•…äº‹çš„æ ¸å¿ƒã€‚ ==è€¶ç¨£çš„è¿™ä¸ªæ‰‹åŠ¿æºäºç±³å¼€æœ—åŸºç½—çš„è¥¿æ–¯å»·å¤©é¡¶ç”»ã€Šåˆ›é€ äºšå½“ã€‹==ï¼Œä»–ä¼¸å‡ºçš„å³æ‰‹ï¼Œå‡ ä¹æ˜¯äºšå½“å·¦æ‰‹çš„é•œåƒã€‚==ä¸Šå¸çš„æ‰‹æŒ‡ä¸äºšå½“çš„æ‰‹æŒ‡å³å°†è§¦ç¢°ï¼Œè±¡å¾ç€ç¥çš„æ™ºæ…§å’Œçµæ€§å³å°†éšç€çµé­‚ä¸€èµ·æ³¨å…¥äººä½“ï¼›åŒæ ·åœ°ï¼Œè€¶ç¨£å°†è¿™ä¸€æ‰‹åŠ¿ä¼ é€’ä¸‹å»ï¼Œå°†ç¥çš„å®½æ•ç»™äºˆä»–çš„ä½¿å¾’ã€‚== å¡æ‹‰ç“¦ä¹”ä¹‹æ‰€ä»¥åœ¨ææ‘¹è€¶ç¨£æ—¶å€Ÿç”¨ã€Šåˆ›é€ äºšå½“ã€‹ä¸­äºšå½“çš„æ‰‹åŠ¿ï¼Œæ˜¯å› ä¸ºè€¶ç¨£åœ¨æ–°çº¦ä¸­è¢«æç»˜ä¸º==æœ€åçš„äºšå½“==æˆ–==ç¬¬äºŒä¸ªäºšå½“==(the Last Adam/the Second adam)ã€‚åœ¨åœ£ç»æ–°çº¦ä¸­ï¼Œä¿ç½—å°†è€¶ç¨£å’Œäºšå½“è¿›è¡Œäº†ä¸¤æ¬¡æ˜ç¡®çš„æ¯”è¾ƒï¼š å› ä¸€äººçš„æ‚–é€†ï¼Œä¼—äººæˆä¸ºç½ªäººï¼›ç…§æ ·ï¼Œå› ä¸€äººçš„é¡ºä»ï¼Œä¼—äººä¹Ÿæˆä¸ºä¹‰äº†ã€‚ â€”â€”ç½—é©¬ä¹¦ 5:19 åœ¨äºšå½“é‡Œä¼—äººéƒ½æ­»äº†ã€‚ç…§æ ·ï¼Œåœ¨åŸºç£é‡Œä¼—äººä¹Ÿéƒ½è¦å¤æ´»ã€‚ â€”â€”å“¥æ—å¤šå‰ä¹¦ 15:22 è€Œåœ¨ 45 èŠ‚ä¸­ï¼Œä»–ç§°è€¶ç¨£ä¸º ==â€œæœ€åçš„/ç»ˆæçš„/æœ€ç»ˆçš„äºšå½“â€ (the last/ultimate/final Adam)==ã€‚ æˆ‘ä»¬å†æ¥çœ‹çœ‹å¡æ‹‰ç“¦ä¹”çš„é…’çª–å¼å…‰çº¿ã€‚åœ¨ã€Šåœ£é©¬å¤ªè’™å¬ã€‹ä¸­ï¼Œä¸€æŸå…‰çº¿ä¼¼ä¹è‡ªè€¶ç¨£å¤´é¡¶ï¼ˆè€Œä¸æ˜¯æ¥è‡ªè‚®è„çš„çª—æˆ·ï¼‰ï¼Œé¡ºç€ä»–çš„æ‰‹ï¼Œå°„å‘äº†ç”»é¢çš„å·¦ä¾§ã€‚è¿™é‡Œå¾ˆå¤šå­¦è€…æ›¾å¯¹çª—æˆ·çš„ä½œç”¨æå‡ºäº†ç–‘é—®ã€‚æœ‰çš„äººè®¤ä¸ºçª—æˆ·æ˜¯ä¸ºäº†å…‰çº¿çš„æ¼«åå°„è€Œå­˜åœ¨ã€‚ä½†æˆ‘è§‰å¾—ï¼Œæ¯”è¾ƒä»¤äººä¿¡æœçš„è¯´æ³•æ˜¯ï¼Œè¿™é‡Œæš—æ·¡çš„çª—æˆ·è±¡å¾ç€æ•™ä¼šï¼šå®ƒåªæ˜¯ä¸€ç§å½¢å¼ï¼Œå¹¶ä¸èƒ½å¸¦æ¥çœŸæ­£çš„å…‰èŠ’ï¼›çœŸæ­£çš„ç¦éŸ³ä¹‹å…‰æºè‡ªäºåŸºç£ï¼Œæºè‡ªäºå¯¹è€¶ç¨£çš„ä¿¡ä»°ã€‚ ç‰¹ç‚¹æ€»ç»“ ","date":"2021-10-18","objectID":"/the-calling-of-saint-mathew/:4:0","tags":null,"title":"å¡æ‹‰ç“¦ä¹”ã€Šåœ£é©¬å¤ªè’™å¬ã€‹","uri":"/the-calling-of-saint-mathew/"},{"categories":null,"content":"æˆå‰§æ€§å’Œå¼ åŠ› è¿™å¹…ç”»çš„æˆå‰§æ€§åœ¨äºï¼Œè¿™ä¸€åˆ»ï¼Œæ²¡æœ‰äººåšä»»ä½•äº‹æƒ…ï¼Œä½†æˆ‘ä»¬éƒ½èƒ½é¢„è§ä¸‹ä¸€ç§’å°†å‘ç”Ÿä»€ä¹ˆã€‚ åŸºç£è¿™ä¸€ç¬æ—¶çš„å‡ºç°æ˜¯å¦‚æ­¤å‡ºäººæ„æ–™ï¼›ä»–çš„å§¿æ€å¦‚æ­¤å¨ä¸¥ï¼Œä»¥è‡³äºåœ¨åœºçš„æ¯ä¸€ä¸ªäººåœ¨å‘ç”Ÿååº”ä¹‹å‰éƒ½æš‚åœäº†è¡ŒåŠ¨ã€‚å†è¿‡ä¸€ç§’ï¼Œé©¬å¤ªå°±ä¼šç«™èµ·æ¥è·ŸéšåŸºç£è€Œå»â€”â€”ä»–è…¿éƒ¨åŠ¨åŠ¿å’Œè‚Œè‚‰çš„æ›²å¼ å·²ç»æš´éœ²äº†è¿™ä¸€ç‚¹ã€‚å¦å¤–ï¼Œä»”ç»†è§‚å¯Ÿç”»é¢å³ä¸‹è§’ä¹Ÿèƒ½å‘ç°ï¼ŒåŸºç£çš„è„šäº‹å®ä¸Šå·²ç»è°ƒè½¬äº†æ–¹å‘ï¼Œä»¿ä½›å°±è¦ç¦»å¼€è¿™ä¸ªæˆ¿é—´ã€‚ä»–æ¥æ­¤åªæ˜¯ä¸ºäº†å‘ŠçŸ¥ä½¿å¾’ä»–å·²è¢«é€‰ä¸­ï¼Œä¸åšä»»ä½•åœç•™ï¼Œå¹¶ä¸”å¿ƒé‡Œä»¿ä½›æ—©å°±çŸ¥é“é©¬å¤ªä¼šæ¯«ä¸çŠ¹è±«åœ°è·Ÿéšè‡ªå·±ã€‚è¿™å¹…ç”»çš„ç‰¹æ®ŠåŠ›é‡å°±åœ¨äºè¿™ç§åŠ¨ä½œçš„åœæ­¢ã€‚æœ‰å¦‚ç‰µä¸æœ¨å¶å¿½è¢«æ‹‰ç´§äº†çº¿ï¼Œè®©äººå¿ƒå¤´ä¹Ÿå€åœ°ä¸€éœ‡ã€‚ ä¹‹åçš„åŠ¨ä½œè™½â€œå‘¼ä¹‹æ¬²å‡ºâ€ä¸”â€œæ˜¾è€Œæ˜“è§â€ï¼Œå´ä¹Ÿç•™è¶³äº†æ‚¬å¿µï¼Œç»™äº†è§‚è€…æ€è€ƒä¸æƒ³è±¡çš„ç©ºé—´ã€‚==å®ƒåˆ©ç”¨äº†ç»˜ç”»æœ€åŸºæœ¬çš„é™æ€æ„Ÿä¼ è¾¾å‡ºäº†äººç±»åŠ¨æ€çš„æƒ…æ„Ÿâ€”â€”åœ¨é¢ä¸´æŒ‘æˆ˜æˆ–å‘½ä»¤ï¼Œå¹¶ä¸”å°šæœªæ¥å¾—åŠååº”ä¹‹æ—¶çš„ï¼Œé‚£ç§å…¸å‹çš„å†…å¿ƒçŸ›ç›¾ä¸çŠ¹è±«ä¸å†³ã€‚== ","date":"2021-10-18","objectID":"/the-calling-of-saint-mathew/:5:0","tags":null,"title":"å¡æ‹‰ç“¦ä¹”ã€Šåœ£é©¬å¤ªè’™å¬ã€‹","uri":"/the-calling-of-saint-mathew/"},{"categories":null,"content":"æ„å›¾ä¸å¯¹æ¯” ç”»é¢åˆ†ä¸ºä¸¤éƒ¨åˆ†ã€‚åŸºç£å’Œåœ£å½¼å¾—çŸ—ç«‹åœ¨å³ä¾§ï¼Œå½¢æˆäº†ä¸€ä¸ªç«–ç›´çš„çŸ©å½¢ï¼›ç”»é¢å·¦ä¾§å›´ååœ¨æ¡Œå­æ—çš„äººä»¬å½¢æˆäº†ä¸€ä¸ªæ°´å¹³çš„æ¨¡å—ã€‚å¡æ‹‰ç“¦ä¹”ä»¥é²œè‰³çš„è‰²å½©ä½¿è¿™å¹…ç”»æ ©æ ©å¦‚ç”Ÿï¼šçº¢è‰²ã€é‡‘è‰²å’Œç»¿è‰²çš„å¤§èƒ†å¯¹æ¯”ã€‚æ­¤å¤–ï¼Œå¤©é¹…ç»’å’Œè½¯æ¯›çš®ç­‰å„ç§è´¨åœ°çš„æœè£…ä¹ŸåŠ å¼ºäº†äººç‰©çš„å¯¹æ¯”ï¼šä»åœ¨ä¸–ä¿—çº·äº‰ä¸­è‹¦è‹¦æŒ£æ‰çš„åˆ©æœªå’Œä»–çš„éƒ¨ä¸‹ä»¬ï¼Œç©¿ç€å…·æœ‰å½“ä»£é£æ ¼çš„è¡£æœï¼›è€ŒåŸºç£å’Œåœ£å½¼å¾—ï¼Œèµ¤ç€åŒè„šï¼Œèº«ç€å…·æœ‰è±¡å¾æ„ä¹‰å’Œæ°¸æ’æ€§çš„æ–—ç¯·ï¼Œå°†åˆ©æœªå¬å”¤åˆ°å¦ä¸€ä¸ªäº†æ— ä¿—å°˜çš„ä¸–ç•Œã€‚==è¿™ä¸¤ä¸ªç¾¤ä½“è¢«ä¸€ä¸ªè™šç©ºéš”å¼€ï¼Œç”±åŸºç£çš„æ‰‹ä»ç”»é¢ä¸Šå¹¶ä¸”ä»è±¡å¾æ„ä¹‰ä¸Šè¿æ¥äº†èµ·æ¥==ã€‚ è¿™åªæ‰‹ï¼Œå°±åƒç±³å¼€æœ—åŸºç½—ã€Šåˆ›é€ äºšå½“ã€‹ä¸­ï¼Œäºšå½“çš„æ‰‹ä¸€æ ·ï¼Œåœ¨å½¢å¼ä¸Šå’Œå¿ƒç†ä¸Šç»Ÿä¸€äº†ä¸¤éƒ¨åˆ†ã€‚åœ¨ç”»é¢èˆå°å¼çš„ç©ºé—´ä¹‹ä¸‹ï¼Œæ˜¯çºµæ¨ªäº¤é”™çš„ç½‘æ ¼å¸ƒå±€ï¼Œå°†æ•´ä½“åœ¨ç»“æ„ä¸Šç¼–ç»‡åœ¨ä¸€èµ·ã€‚ ","date":"2021-10-18","objectID":"/the-calling-of-saint-mathew/:6:0","tags":null,"title":"å¡æ‹‰ç“¦ä¹”ã€Šåœ£é©¬å¤ªè’™å¬ã€‹","uri":"/the-calling-of-saint-mathew/"},{"categories":null,"content":"å¡æ‹‰ç“¦ä¹”çš„é…’çª–å…‰çº¿ ç”»é¢çš„å…‰çº¿ä¹ŸåŒæ ·ç»è¿‡ç²¾å¿ƒå¤„ç†ï¼šç”»é¢å³ä¸Šè§’çš„å…‰æºï¼ŒçŠ¹å¦‚é…’çª–æ€å¼€æ—¶ï¼Œé’»ç¼è€Œå…¥çš„å…‰çº¿ä¸€èˆ¬ï¼ŒæŠ•å°„åœ¨ç”»é¢å·¦ä¾§äººç¾¤çš„è„¸ä¸Šï¼Œä»è€Œå°†åœ£é©¬å¤ªå’Œéšä»ä»¬è„¸éƒ¨çš„ç¥æƒ…å±•ç°åœ°æ·‹æ¼“å°½è‡´ã€‚è€Œè¿™ä¸åŸºç£ä¸€åŒè¿›å…¥äº†è¿™é—´å±‹å­çš„å…‰ï¼Œä¸æ˜¯è‡ªç„¶å…‰ä¹Ÿä¸æ˜¯ç¯å…‰ï¼Œè€Œæ˜¯è±¡å¾ç€ä¸Šå¸çš„ã€ç¥åœ£çš„ã€å¥‡è¿¹èˆ¬çš„å…‰èŠ’âœ¨ã€‚å¦åˆ™ï¼Œä¸ºä»€ä¹ˆåœ£å½¼å¾—æ²¡æœ‰åœ¨ä½©å‰‘ç”·å­©èº«ä¸ŠæŠ•ä¸‹å½±å­å‘¢ï¼Ÿ ","date":"2021-10-18","objectID":"/the-calling-of-saint-mathew/:7:0","tags":null,"title":"å¡æ‹‰ç“¦ä¹”ã€Šåœ£é©¬å¤ªè’™å¬ã€‹","uri":"/the-calling-of-saint-mathew/"},{"categories":null,"content":"Intro to Computing in Python by David Joyner","date":"0001-01-01","objectID":"/gatech-cs1301xiv/","tags":null,"title":"Gatech CS1301xIV","uri":"/gatech-cs1301xiv/"},{"categories":null,"content":"Unit 5 ","date":"0001-01-01","objectID":"/gatech-cs1301xiv/:0:0","tags":null,"title":"Gatech CS1301xIV","uri":"/gatech-cs1301xiv/"},{"categories":null,"content":"Chapter 5.1: Objects ","date":"0001-01-01","objectID":"/gatech-cs1301xiv/:1:0","tags":null,"title":"Gatech CS1301xIV","uri":"/gatech-cs1301xiv/"},{"categories":null,"content":"Basic Concepts Object-oriented programming:Â A programming paradigm where programmers define custom data types that have custom methods embedded within them. Object:Â An object is a custom data structure that organizes and encapsulates variables and methods into a single data type. It is used near-interchangeably with â€œinstance.â€ Itâ€™s like the general â€˜prototypeâ€™ or â€˜templateâ€™. Class:Â A custom data type comprised of multiple variables and/or methods. Instances or objects are created based on the template provided by the class. A class is a generic structure for a certain kind of data. An instance, on the other hand, is a specific example. ","date":"0001-01-01","objectID":"/gatech-cs1301xiv/:1:1","tags":null,"title":"Gatech CS1301xIV","uri":"/gatech-cs1301xiv/"},{"categories":null,"content":"Classes and Instances in Python #Define the class Name class Name: def __init__(self): self.firstname = \"[no first name]\" self.lastname = \"[no last name]\" #Define the class Person class Person: #Create a new instance of Person def __init__(self): #Person's default values self.name = Name() self.eyecolor = \"[no eye color]\" self.age = -1 #Create a new Person and assign it to myPerson myPerson = Person() # with default values #Print myPerson's name's firstname print(myPerson.name.firstname) #Change myPerson's name's firstname to David myPerson.name.firstname = \"David\" #Print myPerson's name's firstname print(myPerson.name.firstname) __init__ is called whenever we create a new instance of a class. It initializes an instance of that class. self is a keyword that tells Python to define variables for the instance as a whole. Any other code inside this class would be able to see those variables, as long as it accessed them with self as well. Besides, because it starts with self, the variable age exists, as long as this class or this instance exists. But if we left off self, then the variable would cease to exist at the end of this method. Every method defined inside a class should have self as the first parameter. Weâ€™ll never have to pass in an argument for it though. Self by default just sees all the variables associated with this instance of the class. Preceding these variable names with the word self just tells Python that the scope of these variables is the entire lifespan of this instance of the class. When we call the class name to create an instance, the color of the class name that was called is the same as __init__. The reason is that when we call the class, it actually calls our init function. This creates a new instance of this class and then returns that instance to be set equal to the variable name on the left. Benefits of using objects instead of dictionaries: With a dictionary, we might not have created a certain key. But with classes, we guarantee that every variable created in that initializer actually exists. Classes can have methods as well as variables. Dictionaries were purely ways of organizing data, but that data couldnâ€™t do anything on its own. Dictionaries only store data, whereas classes can themselves act on data. ","date":"0001-01-01","objectID":"/gatech-cs1301xiv/:1:2","tags":null,"title":"Gatech CS1301xIV","uri":"/gatech-cs1301xiv/"},{"categories":null,"content":"Common Method Types Constructor:Â A common type of method in writing classes that specifies some code to automatically run whenever a new instance of the class is created. The constructor often has parameters that provide values to initialize the variables defined by the class. Destructor:Â A common type of method in writing classes that specifies how the instance of a class is to be destroyed/deleted, such as releasing its memory back to the computer. Destructors can be useful if youâ€™re dealing with massive quantities of data and find yourself running out of computer memory. Getter:Â A common type of method in writing classes that returns the value of a variable contained within the class. They are commonly used to allow other processing to occur whenever the variable is accessed, like logging. Setter:Â A common type of method in writing classes that sets a variable contained within the class to a new value. They are commonly used to allow other processing to occur whenever the variable is changed, like logging. ","date":"0001-01-01","objectID":"/gatech-cs1301xiv/:1:3","tags":null,"title":"Gatech CS1301xIV","uri":"/gatech-cs1301xiv/"},{"categories":null,"content":"Encapsulating Methods in Classes Encapsulation: The ability to combine variables and methods into class definitions in object-oriented programming. It helps avoid modification or misuse of data by other functions or programs. Methods are what make encapsulation truly powerful in classes. A method is a function defined inside of a class. The method scope is defined as the normal scope of a function for that language plus any variables that are visible in the instance of the class as a whole. In practice, the four common method types weâ€™ve' discussed above â€“ constructors, destructors, getters, and setters â€“ are more important to other languages than to Python. Constructors are present, but youâ€™ll rarely use destructors in Python; and getters and setters are antithetical to â€œPythonicâ€ thinking. Python doesnâ€™t provide privacy options for its variables and methods. There is no way to bindingly mark a variable or method in a Python class as private, meaning that other code can always access variables directly. By convention, we often perceive variables or methods that we donâ€™t want other classes or functions to access with a double underscore. The double underscore simply informs other areas of the code that those methods or variables are not meant to be used to access data that way. __init__ is the constructor in Python. And as a function defined inside of a class, it has a parameter list. Self is always the first parameter for any method that we define inside of a class, but it doesnâ€™t have to be the only one. #Define the class Person class Person: #Create a new instance of Person def __init__(self, firstname=\"[no first name]\", lastname=\"[no last name\"): self.firstname = firstname self.lastname = lastname self.eyecolor = \"[no eye color]\" self.age = -1 myPerson1 = Person() print(myPerson1.firstname) # [no first name] myPerson2 = Person(firstname = \"David\") print(myPerson2.firstname) # David myPerson3 = Person(\"Vrushali\") print(myPerson3.firstname) # Vrushali Part of the benefit of getters and setters was that they allow us to run some code whenever a variable is accessed or modified. #Define class BankAccount class BankAccount: #Initialize balance to 0 def __init__(self, name, balance = 0.0): self.log(\"Account created!\") self.name = name self.balance = balance def getBalance(self): #Getter for balance self.log(\"Balance checked at \" + str(self.balance)) return self.balance def setBalance(self, newBalance): #Setter for balance self.log(\"Balance changed to \" + str(newBalance)) self.balance = newBalance def log(self, message): #Logging method myLog = open(\"Log.txt\", \"a\") print(message, file = myLog) myLog.close() myBankAccount = BankAccount(\"David Joyner\") myBankAccount.setBalance(20.0) print(myBankAccount.getBalance()) The log() method will take as a parameter, the message to be logged; and its operation is to automatically open my log, print the message to that log, and then close that log. So every time an account is created, or the balance is checked, or the balance is changed, those operations will get logged to my log file. getBalance() is a getter for getting the balance. Its main function is to return the balance, which is the same thing as accessing the balance directly. Itâ€™s also going to log every time the balance is checked. setBalance() is a setter that sets the value equal to a new balance, and it also logs that as well. We could actually create methods to do whatever we want. And in fact, if we were really designing a bank account class like we were designing here, we probably donâ€™t want a set balance method. How often do we just wipe out the previous balance and set it equal to a new value. Thatâ€™s not the way we usually use bank accounts. Usually we use them by making deposits and making withdrawals. class BankAccount: def __init__(self, name, balance = 0.0): self.log(\"Account created!\") self.name = name self.balance = balance def getBalance(self): self.log(\"Balance checked at \" + str(self.balance)) return self.balance ","date":"0001-01-01","objectID":"/gatech-cs1301xiv/:1:4","tags":null,"title":"Gatech CS1301xIV","uri":"/gatech-cs1301xiv/"},{"categories":null,"content":"Advanced Topics in Classes in Python Combining Classes: 1| class Name: 2| def __init__(self, firstname, lastname): 3| self.firstname = firstname 4| self.lastname = lastname 5| 6| class Student: 7| def __init__(self, studentName, enrolled): 8| self.studentName = studentName 9| self.GPA = 0.0 10| self.creditHours = 0 11| self.enrolled = enrolled 12| self.classes = [] # Legal ways to create a new instance of Student: newStudent = Student(Name(\"David\", \"Joyner\"), True) newName = Name(\"David\", \"Joyner\") newStudent = Student(newName, True) newStudent = Student(\"David Joyner\", True) Instances as arguments (1) class Person: def __init__(self, name, age, father=None, mother=None): self.name = name self.age = age self.father = father self.mother = mother person1=Person(\"Mr. Burdell\",53) person2=Person(\"Mrs. Burdell\",53) george_p=Person(\"George P. Burdell\",25,person1, person2) print(george_p.name) print(george_p.mother.name) print(george_p.father.name) Instance Assignments: when we assign an already existed instance to a new instance, weâ€™ve given the new one access to the old oneâ€™s actual variables (theyâ€™re pointing through the same variable name). So if the new one changes the variables, it changes them from the old one as well. Lists, dictionaries, objects, and most other data types in Python behave this way: they are mutable. Instances as arguments (2) class Person: def __init__(self, name, eyecolor, age): self.name = name self.eyecolor = eyecolor self.age = age class Name: def __init__(self, firstname, lastname): self.firstname = firstname self.lastname = lastname def capitalizeName(name): name.firstname = name.firstname.upper() name.lastname = name.lastname.upper() def capitalizeString(instring): instring = instring.upper() myPerson = Person(Name(\"David\", \"Joyner\"), \"brown\", 30) capitalizeName(myPerson.name) print(myPerson.name.firstname) # DAVID print(myPerson.name.lastname) # JOYNER capitalizeString(myPerson.name.firstname) capitalizeString(myPerson.name.lastname) print(myPerson.name.firstname) # David print(myPerson.name.lastname) # Joyner When we passed in an instance of the name object, capitalizeName actually has access to the original variables and can change them. Itâ€™s not just changing its own local copy, itâ€™s changing the real values of the variables. And so we see in the end that the strings themselves have been converted to all capital letters. Itâ€™s not actually changing the firstname and lastname, itâ€™s changing what name.firstname and name.lastname point at. But when we have capitalizeString instead of capitalizeName, we pass the strings for first name and last name directly instead of passing the name object that contains them. The result here is exactly the opposite, and the reason is that strings are immutable. Here, though, it doesnâ€™t have access to name dot anything. So it canâ€™t change what name is pointing at. It tries to change the value of the string itself, but it has no access to the original variable name, so it canâ€™t actually change the values of first name and last name as far as name is concerned. So the takeaway here is that any operations we make on mutable objects, like name, propagate back out to the code that called that function. Any operations we make to immutable types, like just the plain string, do not propagate out to our main function or to our main code. Then what do you do if you want to make an actual copy of an instance, such that you can actually modify it separately? The basic principle is that you must copy it at the level of the immutable data types (string and integer are immutable, but self-defined classes are mutable). We have to construct a new instance of person and pass in those immutable data types as arguments, as opposed to just setting myPerson2 directly equal to myPerson1. This forces the computer to create a new instance of person, with its own variables for name, eye color, and age. class Person: def __init__(self, name, eyecolor, age): self.name = name self.eyecolor = eyec","date":"0001-01-01","objectID":"/gatech-cs1301xiv/:1:5","tags":null,"title":"Gatech CS1301xIV","uri":"/gatech-cs1301xiv/"},{"categories":null,"content":"Polymorphism and Inheritance and Abstraction Abstraction:Â A principle of object-oriented programming that states that only essential information should be made visible to the outside program. Certain variables only makes sense at certain levels of abstraction. Polymorphism:Â The principle that a method call can behave differently depending on the arguments and object with which it is called. Polymorphism describes the ability to write a method in each class that would allow drastically dissimilar objects to be accessed and used in the same way. Inheritance:Â A principle of object-oriented programming where classes can be created that are â€œsubclassesâ€ of other classes, inheriting all the variables and methods from the other class while supplying new variables, methods, or behaviors of these own. Inheritance is the idea that an object can inherit certain variables and methods from its parent. ","date":"0001-01-01","objectID":"/gatech-cs1301xiv/:1:6","tags":null,"title":"Gatech CS1301xIV","uri":"/gatech-cs1301xiv/"},{"categories":null,"content":"External Materials ğŸClasses and Objects - the BasicsÂ andÂ Classes and Objects - Digging a Little Deeper, from How to Think Like a Computer Scientist ","date":"0001-01-01","objectID":"/gatech-cs1301xiv/:1:7","tags":null,"title":"Gatech CS1301xIV","uri":"/gatech-cs1301xiv/"},{"categories":null,"content":"Chapter 5.2: Algorithms Algorithm: Technically, a collection of steps that transforms input into output; commonly, a complex set of lots of steps that is only feasible to perform with the efficiency of a computer. They generally exist separate and apart from our particular computer implementation of them. Famous Algorithms: Data compression: taking very large files and communicating them with a fraction of the data in a way that loses as little actual meaning as possible. Algorithms responsible for effective compression are used to run video streaming services, online multiplayer games, and more. Random number generation: algorithms that take some variable input and use it to algorithmically replicate something resembling truly random numbers. Search algorithms: search in the way that in internet search engines. Algorithms underlie Googleâ€™s efforts to predict what youâ€™re searching for based on your keywords, relationships between websites, and past users experiences. ","date":"0001-01-01","objectID":"/gatech-cs1301xiv/:2:0","tags":null,"title":"Gatech CS1301xIV","uri":"/gatech-cs1301xiv/"},{"categories":null,"content":"Complexity and Big O Notation Complexity:Â The rate at which the number of operations requires to run an algorithm grows based on the value of the input on which it operates. Usually when discussing complexity we talk in terms of worst case scenarios, also known as â€œupper boundsâ€ on how long something could take. Big O Notation:Â A notation for expressing the worst-case efficiency of an algorithm in terms of the size of the input. Big o is a measure of algorithmic complexity. In big o we ask, given a data set of size n, how many operations are required to complete this algorithm? However, what weâ€™re really interested in with big o notation, are differences of orders of magnitude. So itâ€™s common to leave out the coefficients and describe algorithms simply as having o of terms just related to n (e.g., n squared) complexity. In fact, the â€œoâ€ in big o notation, stands for the order of the function. There also exist BigÂ Î© (Omega)Â Notation, which expresses the best-case efficiency of an algorithm, and BigÂ Î¸ (Theta) Notation, which expresses the typical-case efficiency of an algorithm. Big O is used most commonly. These various values exist, though, because some algorithms are generally very efficiency, but are very inefficient with certain types of data. For example, there exists a sorting algorithm called QuickSort that is generally extremely efficient, but whose efficiency plummets if there are a lot of duplicate values in the data set that itâ€™s sorting. Common Big O Values: table th:first-of-type { width: 10%; } table th:nth-of-type(2) { width: 20%; } table th:nth-of-type(3) { width: 35%; } Name Big O Notation Definition Example Constant !$O(1)$ The same number of operations is required regardless of the size of the data set. â€œIs the first name in the data set â€˜Davidâ€™?â€ Linear !$O(n)$ The number of operations required increases linearly with the size of the data set. â€œIs the name â€˜Davidâ€™ in this unsorted list of names?â€ (Linear Search) Quadratic !$O(n^2)$ The number of operations required increases with the size of the data set squared. â€œAre there any duplicate names in this unsorted list of names?â€ (Double-Linear Search) Polynomial !$O(n^3)$ The number of operations required increases with the size of the data set raised to a larger exponent. â€œAre there any triple duplicate names in this unsorted list of names?â€ (Triple-Linear Search) Exponential !$O(2^n)$ The number of operations required increases by a constant raised to the size of the data set. â€œWhat is every possible 10-digit password?â€ Logarithmic !$O(log(n))$ The number of operations required increases with the square root of the size of the data set. â€œIs the name â€˜Davidâ€™ in this sorted list of names?â€ (Binary Search) Loglinear !$O(nlog(n))$ The number of operations required increases with square root of the size of the data set times the size of the data set. (tends to be the optimal efficiency for most sorting algorithms) â€œSort this list of names.â€ (Merge Sort) Factorial !$O(n!)$ The number of operations required increases with the factorial of the size of the data set. (tends to come up a lot in recursive algorithms) â€œWhat is shortest possible route among these multiple destinations?â€ ","date":"0001-01-01","objectID":"/gatech-cs1301xiv/:2:1","tags":null,"title":"Gatech CS1301xIV","uri":"/gatech-cs1301xiv/"},{"categories":null,"content":"Recursion ğŸ¤¡ The definition of recursion is â€œsee the definition of recursionâ€. Recursion is a programming method characterized by functions that, during their operation, call additional copies of themselves; see also, recursion. Recursion involves breaking down a problem into smaller instances recursively until each of them can be independently solved. Solutions to these smaller instances combine to form the solution for the original problem. It keeps calling another version of itself until it reaches some default condition. This is a little bit related to our idea of a stack. We kept adding new functions on top of the stack until we reached the bottom. And then we removed them in the opposite order from how we added them. This is why we noted that the stack was more common than the queue in computing, where calls are added to the top until one is ready to return something. The important thing is that the first one to return was the last one to be called. Examples include facrotial, Fibonacci sequence The recursive implementation of Fibonacci is very inefficient. We could make it more efficient if we replace these calls of Fibonacci directly with a function that looks up and sees â€œhave I already calculated the Fibonacci number at this location?â€ And if so, just go ahead and grab that value instead of recalculating it manually. We would probably do that with a dictionary, where the keys in the dictionary are locations in the sequence and the values are the Fibonacci numbers at those locations. In doing so, we remove all those duplicate calls to Fibonacci with the same value that are used before. Head recursion and tail recursion: Head recursion occurs when the recursive call is near the beginning of the function, before other reasoning or code. Tail recursion occurs when the recursive call is closer to the end of the function, after some other reasoning or code. Notice that the way Iâ€™ve written this function right now it would first print all the files in the current folder and then it would dive into the sub folders. So if we ran this we would see all the files and directory first, followed by all the files in the first folder found within directory, followed by all the files found in the first folder within that folder, and so on. If I had reversed these though, then it would first print the files located in the deepest subfolder of directory. And the very last thing it would do is print the files located in the current directory itself. Thatâ€™s because it would be making that recursive function call at the beginning instead of at the end. Calling the recursive function as shown here, at the end, is called tail recursion. Whereas if it was at the start, it would be called head recursion. ","date":"0001-01-01","objectID":"/gatech-cs1301xiv/:2:2","tags":null,"title":"Gatech CS1301xIV","uri":"/gatech-cs1301xiv/"},{"categories":null,"content":"Sorting Algorithms Sorting Algorithms take as input a list, and produce as output a sorted version of that list. The only stipulation is the algorithm must have some way to judge whether one item is greater than, less than, or equal to another. Examples include bubble sort, insertion sort, selection sort, merge sort, shell sort, quick sort, and heap sort. ğŸ¥‡For some awesome visualizations of sorting algorithms in action, check outÂ Toptalâ€™s web site. Bubble Sort Difficulty: â­ Efficiency: âš¡ Complexity: !$O(n^2)$ Implementation: iterate through each item in the list one pair at a time. If that pair were in the wrong order then switch them. Repeat that process so long as a switch occurred the previous time we went through the list. When no switches are required, then that means the list was sorted. Each time we go through the list, the bubble sort finds the largest number that has not been in the right place and puts it into the right spot by switching pairs. The benefit of bubble sort is that itâ€™s actually pretty easy to write. Itâ€™s effectivelyâ€“ for each number in the list swap it if itâ€™s greater than the next number, and keep a running Boolean that says true if any swaps were necessary. You reset that boolean to false at the end of each execution, but rerun the bubble sort if it was true at the end of the execution. The drawback of a bubble sort is itâ€™s actually pretty inefficient. A lot of swaps were unnecessary. So itâ€™s probably the easiest sort to implement, but it also operates in an inefficient timeâ€“ o of n squared. (Orange arrows stand for iterations) def BubbleSort(list): #Set swap_occurred to True to guarantee the loop runs once swap_occurred = True #Run the loop as long as a swap occurred the previous time while swap_occurred: #Start off assuming a swap did not occur swap_occurred = False #For every item in the list except the last one... for i in range(len(list) - 1): #If the item should swap with the next item then swap if list[i] \u003e list[i + 1]: list[i], list[i+1] = list[i + 1], list[i] # Record that a swap has occurred swap_occurred =True return list Selection Sort Difficulty: â­â­ Efficiency: âš¡âš¡ Complexity: !$O(n^2)$ Implementation: go through the list, find the lowest or the first item, and move that item to the beginning. Then go through starting with the second item, find the next lowest item, and continue. Each time we go through the list, the selection sort finds the smallest number that has not been in the right place and puts it into the right spot directly. Because on that first run, it guaranteed it would find the very first number that should be in the list, it starts the second run by searching just from the second number onwards. After each run of selection sort, a new number at the beginning of the list is now in the right location. Notice also that if a number ends up accidentally in the right location after a certain run, it doesnâ€™t save selection sort an execution, because it tries to move that number into its current location. Thus, with selection sort we guarantee weâ€™re going to go through the list n times, where n is the number of items in the list. Because even if an element in the list is already in the right place, it still runs one time to try and put it in the right place. So like bubble sort, selection sort runs in o of n squared. We still repeatedly compare every pair but we track the lowest and move it to the beginning. Selection sort cannot skip iterations of the sort, so there will always be one fewer iteration than items in the list. The answer is one fewer iteration because when items 1 through n - 1 are sorted, item n is guaranteed to be sorted, too. (Orange arrows stand for iterations) def SelectionSort(list): for i in range(len(list)): #Assume first that current item is already correct... minIndex = i #For each index from i to the end... for j in range(i + 1, len(list)): if list[j]\u003clist[minIndex]: minIndex=j #Save the current minimum value since we're about to delete it minValue = list","date":"0001-01-01","objectID":"/gatech-cs1301xiv/:2:3","tags":null,"title":"Gatech CS1301xIV","uri":"/gatech-cs1301xiv/"},{"categories":null,"content":"Search Algorithms Search Algorithms take as input a list and a value for which to search, and produce as output the index or indices where that value was found in the list. Search algorithms are far more efficient than sorting algorithms. In many ways sorting algorithms are just repeated search algorithms that react to the results by moving values around. Thus, a sorting algorithm operates kind of like searching for each value in the list, one by one. Linear Search Complexity: !$O(n)$ A linear search is exactly what you would do if you were searching for a name on an unsorted list or a number in an unsorted list of numbers. You check every item one by one, and when you found the right one youâ€™d stop. The benefit of the linear search is that it works whether or not the list is sorted. Binary Search Complexity: !$O(log(n))$ A binary search on the other hand, works only if the list is already sorted. Itâ€™s a recursive method. And it starts by selecting the middle item from the list. If there is no middle item, itâ€™ll choose randomly. Or it might always use the lower, one or the higher one, doesnâ€™t really matter which. Linear Search vs. Merge Sort + Binary Search The drawback of binary search is that the list must be sorted. So, is it more efficient to do a linear search, or is it more efficient to do a binary search after doing a merge sort? Just look at the complexity we can get the conclusion that, in general, linear search is going to be much more efficient. And that has nothing to do with the efficiency of the binary search, since merge sort is already !$log(n)$ times slower than a linear search. Complexity of Linear Search: !$O(n)$ Complexity of Merge Sort + Binary Search: !$O(nlog(n))+O(log(n))$ So if we have an unsorted list and weâ€™re only looking for one value, then a linear search will always be more efficient than sorting and then using a binary search. However, if youâ€™re going to be searching more than once, that advantage disappears pretty quickly. Imagine you have a list with 100 elements. Sorting that list will require about 800 operations, and then you need at most 7 searches to find any given item in that list. A single linear search on an unsorted list of 100 takes 100 operations. So if weâ€™re going to do as few as nine searches per time, itâ€™s actually more efficient to do a merge sort followed by binary searches. The merge sort incurs a one time flat cost of 800 operations, but the binary search saves us 93 operations per time. So at nine searches, it will require 900 operations with a linear search, but 863 with a merge sort followed by binary searches. Then for every subsequent round, weâ€™re saving 93 additional operations by sorting first. ","date":"0001-01-01","objectID":"/gatech-cs1301xiv/:2:4","tags":null,"title":"Gatech CS1301xIV","uri":"/gatech-cs1301xiv/"}]